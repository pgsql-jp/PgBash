#####################################################
# pgbashrc-8.3
#
# This file must be copied to '/etc' directory.
#
# You may copy '/etc/pgbashrc' to '~/.pgbashrc', and
# you can modify your ~/.pgbashrc file. Pgbash tends
# to read ~/.pgbashrc first. If it does not exist, 
# Pgbash tents to read /etc/pgbashrc.
#####################################################

PGBASHRC_VERSION=8.3

#----------------------------------------------------
# Prompt           
#----------------------------------------------------
# \u: login user name
# \w: current directory
# \h: host name
#----------------------------------------------------
#PS1="pgbash[\u@\h]\w> "
#PS1="[pgbash]\w> "
#PS1="pgbash[\u]\w> "
PS1="pgbash> "

#****************************************************
#					Help Menu
#****************************************************
function _help_menu {
	echo "Informational"
	echo "  ?              : this help (add '+' for more detail)"
	echo "  ?h [SQL]       : help on syntax of SQL commands"
	echo "  ?l[+]          : list databases"
	echo "  ?d [NAME]      : describe table,view,index, or sequence"
	echo "  ?d{t|i|v|s}[+] : list {tables/indexes/views/sequences}"
	echo "  ?dS[+]         : list system tables"
	echo "  ?da            : list aggregate functions"
	echo "  ?db[+]         : list tablespaces"
	echo "  ?dc            : list conversions"
	echo "  ?dC            : list casts"
	echo "  ?dd            : show comment for object"
	echo "  ?dD            : list domains"
	echo "  ?df[+]         : list functions"
	echo "  ?dF[dtp][+]    : list text search [dictionarys/templates/parsers] config."
	echo "  ?dn[+]         : list schemas"
	echo "  ?do            : list operators"
	echo "  ?dp            : list table, view, and sequence access privileges, same as ?z"
	echo "  ?dT[+]         : list data_types"
	echo "  ?du            : lst roles (users), same as ?dg"
	echo ""
	echo "Large Objects"
	echo "  ?lo_import     : lo_import <INPUT_FILE_NAME> <'COMMENT'>"
	echo "  ?lo_export     : lo_export <LOBOID> <OUTPUT_FILE_NAME>"
	echo "  ?lo_unlink     : lo_unlink <LOBOID> "
	echo "  ?lo_list       : list LARGE OBJECTs, same as ?dl"
	echo ""
	echo "Connection"
	echo "  ?con[nect] DBNAME[@SERVER][:PORT] [CONNECT_NAME [USERID [PASSWORD]]]" 
	echo "                 : connect to new database"
	echo "  ?set[connection] CONNECT_NAME"
	echo "                 : change database connection"
	echo "  ?dis[connect]   {CONNECT_NAME | ALL}"
	echo "                 : disconnect databases"
	echo "  ?encoding [ENCODING]"
	echo "                 : show or set client encoding"
	echo "  ?password USERNAME"
	echo "                 : securely change the password for a user"
	echo "Status"
	echo "  ?dbc[onnection]: show database connection"
	echo "  ?opt[ion]      : show current values of exec_sql_OPTIONs"
	echo "  ?sta[tus]      : show STATUS after executing SQL"
	echo "  ?ver[sion]     : show PostgreSQL and pgbash VERSION"
	echo ""
	echo "Formatting"
	echo "  E{+|-}         : turn on/off ECHO_QUERY sent to the backend"
	echo "  L{+|-}         : turn on/off OUTER_FRAME_print"
	echo "  T{+|-}         : turn on/off TOP_header_print"
	echo "  B{+|-}         : turn on/off BOTTOM_count_print"
	echo "  A{+|-}         : turn on/off ALIGNMENT of plain text"
	echo "  X{+|-}         : turn on/off EXPANDED format"
	echo "  H{+|-}         : turn on/off HTML table format"
	echo "  C+  [string]   : set CAPTION string          or DEFAULT('')"
	echo "  S+  [chr]      : set SEPARATOR  (e.g. ','  ) or DEFAULT('|')"
	echo "  N+  [str]      : set NULL_STRING(e.g. '*N*') or DEFAULT('')"
	echo "  Z+  [str]      : set ZERO_STRING(e.g. '*0*') or DEFAULT('')"
	echo ""
	echo "Pgbash help"
	echo "  ??             : help with pgbash usage"
	echo "  ??connect      : help with CONNECTION usage"
	echo "  ??sql          : help with SQL usage"
	echo "  ??sqlcode      : help with SQLCODE"
	echo "  ??exec_sql     : help with 'exec_sql' usage"
}


#****************************************************
# 				alias / functions
#****************************************************

#---------------------------------------------------
#				Informational
#---------------------------------------------------
alias ?='_help_menu            | more'
alias ?h='_help_sql'

alias ?u='_list_roles          | more'
alias ?dg='_list_roles         | more'
alias ?du='_list_roles         | more'

alias ?l='_list_databases      | more'
alias ?l+='_list_databases "+" | more'

alias ?z='_list_privileges     | more'
alias ?dp='_list_privileges    | more'

function ?d {
	case "$#" in
	0 ) _list_relations  | more   ;;
	* ) _list_relation   $1       ;;
	esac
}

alias ?dt='_list_tables        | more'
alias ?dt+='_list_tables "+"   | more'

alias ?di='_list_indexes       | more'
alias ?di+='_list_indexes "+"  | more'

alias ?dv='_list_views         | more'
alias ?dv+='_list_views "+"    | more'

alias ?ds='_list_sequences     | more'
alias ?ds+='_list_sequences "+"| more'

alias ?dS='_list_systables     | more'
alias ?dS+='_list_systables "+"| more'

alias ?da='_list_aggregates    | more'

alias ?db='_list_tablespaces      | more'
alias ?db+='_list_tablespaces "+" | more'

alias ?dc='_list_conversions   | more'
alias ?dC='_list_casts         | more'
alias ?dd='_list_comment       | more'
alias ?dD='_list_domains       | more'

alias ?df='_list_functions     | more'
alias ?df+='_list_functions "+"| more'

alias ?dF='_list_textconfig      | more'
alias ?dF+='_list_textconfig "+" | more'

alias ?dFd='_list_textdict       | more'
alias ?dFd+='_list_textdict "+"  | more'

alias ?dFt='_list_texttemple     | more'
alias ?dFt+='_list_texttemple "+"| more'

alias ?dFp='_list_textparser     | more'
alias ?dFp+='_list_textparser "+"| more'

alias ?dn='_list_schemas       | more'
alias ?dn+='_list_schemas "+"  | more'

alias ?do='_list_operators     | more'

alias ?dT='_list_types         | more'
alias ?dT+='_list_types "+"    | more'

#---------------------------------------------------
#				Formatting
#---------------------------------------------------
alias E+='set OPTION_ECHO=TRUE;'
alias E-='set OPTION_ECHO=FALSE;'
alias L+='set OPTION_FRAME=TRUE;'
alias L-='set OPTION_FRAME=FALSE;'
alias X+='set OPTION_EXPANDED=TRUE;'
alias X-='set OPTION_EXPANDED=FALSE;'
alias H+='set OPTION_HTML=TRUE;'
alias H-='set OPTION_HTML=FALSE;'
alias A+='set OPTION_ALIGNMENT=TRUE;'
alias A-='set OPTION_ALIGNMENT=FALSE;'
alias T+='set OPTION_HEADER=TRUE;'
alias T-='set OPTION_HEADER=FALSE;'
alias B+='set OPTION_BOTTOM=TRUE;'
alias B-='set OPTION_BOTTOM=FALSE;'

function C+ {
	case "$#" in
 	0 ) exec_sql "set OPTION_CAPTION;"        ;;
	* ) exec_sql "set OPTION_CAPTION='$1';"   ;;
	esac
}

function S+ {
	case "$#" in
 	0 ) exec_sql "set OPTION_SEPARATOR;"        ;;
	* ) exec_sql "set OPTION_SEPARATOR='$1';"   ;;
	esac
}

function N+ {
	case "$#" in
	0 ) exec_sql "set OPTION_NULLSTRING;"       ;;
	* ) exec_sql "set OPTION_NULLSTRING='$1';"  ;;
	esac
}

function Z+ {
	case "$#" in
	0 ) exec_sql "set OPTION_ZEROSTRING;"       ;;
	* ) exec_sql "set OPTION_ZEROSTRING='$1';"  ;;
	esac
}

#---------------------------------------------------
#				Large Objects
#---------------------------------------------------
alias ?lo_export='_lo_export'
alias ?lo_import='_lo_import'
alias ?lo_unlink='_lo_unlink'
alias ?lo_list='_lo_list'
alias ?dl='_lo_list      | more'

function _lo_export { 
	case "$#" in
	0 ) echo "_lo_export <OID> <FILE_NAME>" ;;
	* ) exec_sql -x lo_export "$1,'$2'"     ;;
	esac
}
function _lo_import { 
	case "$#" in
	0 ) echo "_lo_import <FILE_NAME> <'COMMENT'>" ;;
	* ) exec_sql -x lo_import "'$1','$2'"         ;;
	esac
}
function _lo_unlink { 
	case "$#" in
	0 ) echo "_lo_unlink <OID>"   ;;
	* ) exec_sql -x lo_unlink "$1" ;;
	esac
}


#----------------------------------------------------
# 				Connection
#----------------------------------------------------
alias ?con='_connect'
alias ?connect='_connect'
function _connect {
	case "$#" in
	1) exec_sql "connect to $1"
	   _disp_connection		;;
	2) exec_sql "connect to $1 as $2"
	   _disp_connection		;;
	3) exec_sql "connect to $1 as $2 user $3"
	   _disp_connection		;;
	4) exec_sql "connect to $1 as $2 user $3 $4"
	   _disp_connection		;;
	*) echo "?con[nect] DBNAME[@SERVER][:PORT] [CONNECT_NAME [USERID [PASSWD]]]"	;;
	esac
}

alias ?set='_setconnection'
alias ?setconnection='_setconnection'
function _setconnection {
	case "$#" in
	1) exec_sql "set connection $1"
	   _disp_connection		;;
	*) _show_connection
	   echo "?set[connection] CONNECT_NAME"		;;
	esac
}

alias ?dis='_disconnect'
alias ?disconnect='_disconnect'
function _disconnect {
	case "$#" in
	1) exec_sql "disconnect $1"	
	   _disp_connection		;;
	*) _show_connection		
	   echo "?dis[connect] {COONECT_NAME | ALL}"	;;
	esac
}

alias ?encoding='_set_client_encoding'
function _set_client_encoding {
	case "$#" in
	1) exec_sql "set client_encoding to '$1'"	
	   _disp_connection		;;
	*) _show_connection		;;
	esac
}

function _disp_connection {
	if [ $SQLCODE = 0 ]; then
		_show_connection
	fi
}

alias ?password='_change_password'
function _change_password {

	case "$#" in
	1) read -sp "Enter new password:" passwd1
	   echo ""
	   read -sp "Enter it again:" passwd2
	   echo ""
	   if [ $passwd1 != $passwd2 ]; then
		echo "Passwords didn't match."
		return;
	   fi
	   exec_sql "ALTER ROLE $1 with password '$passwd1';"	;;

	*) echo "?password USERNAME"	;;
	esac
}

#----------------------------------------------------
# 				Status
#----------------------------------------------------
alias ?dbc=_show_connection
alias ?dbconnection=_show_connection
alias ?opt='_show_exec_sql_option | more'
alias ?option='_show_exec_sql_option | more'
alias ?sta=_show_sqlcode
alias ?status=_show_sqlcode
alias ?ver=_show_version
alias ?version=_show_version

#----------------------------------------------------
# 				Pgbash help
#----------------------------------------------------
alias ??='_help_usage             | more'
alias ??sql='_help_sql_usage      | more'
alias ??connect='_help_connection | more'
alias ??sqlcode='_help_sqlcode    | more'
alias ??exec_sql='help exec_sql   | more'


#****************************************************
#	        List of Database Informations
#****************************************************

# ?u, ?du, ?dg

function _list_roles 
{ 		
	echo "[ List of roles ]"

	SELECT r.rolname AS "Role name",
		CASE WHEN r.rolsuper THEN 'yes' ELSE 'no' END AS "Superuser",
		CASE WHEN r.rolcreaterole THEN 'yes' ELSE 'no' END AS "Create role",
		CASE WHEN r.rolcreatedb THEN 'yes' ELSE 'no' END AS "Create DB",
		CASE WHEN r.rolconnlimit < 0 THEN CAST('no limit' AS pg_catalog.text)
			ELSE CAST(r.rolconnlimit AS pg_catalog.text)
		END AS "Connections",
			ARRAY(
				SELECT b.rolname 
				FROM pg_catalog.pg_auth_members m 
					JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid) 
				WHERE m.member = r.oid
			) as "Member of"
	FROM pg_catalog.pg_roles r
	ORDER BY 1;
	
    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any roles."
    fi
} 

# ?l

function _list_databases()
{
	echo "[ List of databases ]"

	if [ $# -lt 1 ]; then

	SELECT d.datname as "Name", r.rolname as "Owner",
		pg_catalog.pg_encoding_to_char(d.encoding) as "Encoding"
	FROM pg_catalog.pg_database d
		JOIN pg_catalog.pg_roles r ON d.datdba = r.oid
	ORDER BY 1;

	else

	SELECT d.datname as "Name", r.rolname as "Owner",
		pg_catalog.pg_encoding_to_char(d.encoding) as "Encoding",
		t.spcname as "Tablespace",
		pg_catalog.shobj_description(d.oid, 'pg_database') as "Description"
	FROM pg_catalog.pg_database d
		JOIN pg_catalog.pg_roles r ON d.datdba = r.oid
		JOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid
	ORDER BY 1;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any databases."
    fi
} 

# ?z, ?dp

function _list_privileges 
{
	echo "[ List of access privileges ]"

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind  WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'S' THEN 'sequence' 
		END as "Type",
		c.relacl as "Access privileges"
	FROM pg_catalog.pg_class c
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r', 'v', 'S') 
		AND n.nspname !~ '^pg_' AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1, 2;

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any privileges."
    fi
}  
function _list_permissions
{
	_list_privileges
}

# ?d

function _list_relations 
{ 
	echo "[ List of relations ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
			WHEN 'v' THEN 'view' 
			WHEN 'i' THEN 'index' 
			WHEN 'S' THEN 'sequence' 
			WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','v','S','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
			WHEN 'v' THEN 'view' 
			WHEN 'i' THEN 'index' 
			WHEN 'S' THEN 'sequence' 
			WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','v','S','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any relations."
	fi
}

# ?d NAME

function _list_relation  # $1 : table/index/sequence name
{  

	# Table info.
	SELECT c.oid, n.nspname, c.relname 
	INTO  :oid,  :nspname,  :relname
	FROM pg_catalog.pg_class c
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relname ~ '^($1)$'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 2, 3; 

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any relations."
		return;
	fi

	# General table info.
	SELECT relhasindex, relkind, relchecks, reltriggers, relhasrules, relhasoids , reltablespace
	INTO  :relhasindex,:relkind,:relchecks,:reltriggers,:relhasrules,:relhasoids ,:reltablespace
	FROM pg_catalog.pg_class 
	WHERE oid = '$oid';

	# Title
	case $relkind in
	'r') echo "[ Table \"$1\" ]";;
	'v') echo "[ View \"$1\" ]";;
	's') echo "[ Sequence \"$1\" ]";;
	'i') echo "[ Index \"$1\" ]";;
	'S') echo "[ Special relation \"$1\" ]";;
	't') echo "[ TOAST table \"$1\" ]";;
	'c') echo "[ Composite type \"$1\" ]";;
	*)   echo "[ Relation \"$1\" ]";;
	esac

	# Column Info.
	if [ $# -lt 2 ]; then

	SELECT 	a.attname as "Column", 
		pg_catalog.format_type(a.atttypid, a.atttypmod) as "Type",
		CASE WHEN a.attnotnull = 't' THEN 'not null' ELSE '' END AS "NotNull",
		(
		SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)
		FROM pg_catalog.pg_attrdef d
		WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef
		) as "Default"
	FROM pg_catalog.pg_attribute a
	WHERE a.attrelid = '$oid' AND a.attnum > 0 AND NOT a.attisdropped
	ORDER BY a.attnum;

	else

	SELECT 	a.attname as "Column", 
		pg_catalog.format_type(a.atttypid, a.atttypmod) as "Type",
		CASE WHEN a.attnotnull = 't' THEN 'not null' ELSE '' END AS "NotNull",
		(
		SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)
		FROM pg_catalog.pg_attrdef d
		WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef
		) as "Default",
		pg_catalog.col_description(a.attrelid, a.attnum) as "Description"
	FROM pg_catalog.pg_attribute a
	WHERE a.attrelid = '$oid' AND a.attnum > 0 AND NOT a.attisdropped
	ORDER BY a.attnum;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Check if table is a view
	if [ $relkind = "v" ]; then
		SELECT pg_catalog.pg_get_viewdef('$oid'::pg_catalog.oid, true)
		INTO  :viewdef;

		echo "View definition:"
		echo "$viewdef"
		echo ""

		### count rules other than the view rule:
		SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))
		FROM pg_catalog.pg_rewrite r
		WHERE r.ev_class = '$oid' AND r.rulename != '_RETURN' 
		ORDER BY 1;
	fi

	# Fromatting
	T-
	B-
	S+ ":"

	# Indexes
	C+ "Indexes"

	SELECT c2.relname as "Name", 
		pg_catalog.pg_get_indexdef(i.indexrelid, 0, true) as "Index"
		###	c2.reltablespace as "tablespace"
	FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i 
	WHERE c.oid = '$oid' AND c.oid = i.indrelid AND i.indexrelid = c2.oid
	ORDER BY i.indisprimary DESC, i.indisunique DESC, c2.relname;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Check constraints:
	C+ "Check constraints"

	SELECT 	r.conname as "Name", 
			pg_catalog.pg_get_constraintdef(r.oid, true) as "Check"
	FROM pg_catalog.pg_constraint r
	WHERE r.conrelid = '$oid' AND r.contype = 'c' 
	ORDER BY 1;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Rules:
	C+ "Rules"

	SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))
	FROM pg_catalog.pg_rewrite r
	WHERE r.ev_class = '$oid' 
	ORDER BY 1;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Triggers:
	C+ "Triggers"

	SELECT 	t.tgname as "Name", 
			pg_catalog.pg_get_triggerdef(t.oid) as "Trigger"
	FROM pg_catalog.pg_trigger t
	WHERE t.tgrelid = '$oid' AND t.tgconstraint = 0
	ORDER BY 1;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Foreign keys:
	C+ "Foreign keys"

	SELECT 	conname as "Name", 
			pg_catalog.pg_get_constraintdef(oid, true) as "Foreign key"
	FROM pg_catalog.pg_constraint r
	WHERE r.conrelid = '$oid' AND r.contype = 'f' 
	ORDER BY 1;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Inherits:
	C+ "Inherits"

	SELECT c.oid::regclass as "Inherits"
	FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i 
	WHERE c.oid=i.inhparent AND i.inhrelid = '$oid' 
	ORDER BY inhseqno ASC;

	# Fromatting
	C+
	T+
	B+
	S+ "|"
}

# ?dt

function _list_tables()
{
	echo "[ List of tables ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any tables."
    fi
}  

# ?di

function _list_indexes()
{
	echo "[ List of indexes ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		c2.relname as "Table"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid
		LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid
	WHERE c.relkind IN ('i','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		c2.relname as "Table",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid
		LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid
	WHERE c.relkind IN ('i','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any indexes."
    fi
}  

# ?dv

function _list_views()
{
	echo "[ List of views ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('v','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('v','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any views".
    fi
}

# ?ds

function _list_sequences()
{
	echo "[ List of sequences ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind  WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('S','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind  WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('S','')
		AND n.nspname <> 'pg_catalog'
		AND n.nspname !~ '^pg_toast'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any sequences."
    fi
}  

# ?dS

function _list_systables()
{
	echo "[ List of system tables ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','v','S','s','') 
		AND n.nspname = 'pg_catalog'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','v','S','s','') 
		AND n.nspname = 'pg_catalog'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any sequences."
    fi
}  

# ?da

function _list_aggregates 
{
	echo "[ List of aggregate functions ]"

	SELECT n.nspname as "Schema", p.proname AS "Name",
		pg_catalog.format_type(p.prorettype, NULL) AS "Result data type",
		CASE WHEN p.pronargs = 0 THEN CAST('*' AS pg_catalog.text)
	    ELSE pg_catalog.array_to_string(ARRAY(
			SELECT pg_catalog.format_type(p.proargtypes[s.i], NULL)
			FROM pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)
			), ', ')
		END AS "Argument data types",
		pg_catalog.obj_description(p.oid, 'pg_proc') as "Description"
	FROM pg_catalog.pg_proc p
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
	WHERE p.proisagg
		AND pg_catalog.pg_function_is_visible(p.oid)
	ORDER BY 1, 2, 3;

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any aggregate functions."
	fi
}

# ?db

function _list_tablespaces()
{
	echo "[ List of tablespaces ]"

	if [ $# -lt 1 ]; then

	SELECT spcname AS "Name",
		pg_catalog.pg_get_userbyid(spcowner) AS "Owner",
		spclocation AS "Location"
	FROM pg_catalog.pg_tablespace
	ORDER BY 1;

	else

	SELECT spcname AS "Name",
		pg_catalog.pg_get_userbyid(spcowner) AS "Owner",
		spclocation AS "Location",
		spcacl AS "Access privileges",
		pg_catalog.shobj_description(oid, 'pg_tablespace') AS "Description"
	FROM pg_catalog.pg_tablespace
	ORDER BY 1;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any tablespaces."
	fi
}

# ?dc

function _list_conversions 
{
	echo "[ List of conversions ]"

	SELECT n.nspname AS "Schema",
		c.conname AS "Name",
		pg_catalog.pg_encoding_to_char(c.conforencoding) AS "Source",
		pg_catalog.pg_encoding_to_char(c.contoencoding) AS "Destination",
		CASE WHEN c.condefault THEN 'yes'
		ELSE 'no' END AS "Default?"
	FROM pg_catalog.pg_conversion c, pg_catalog.pg_namespace n
	WHERE n.oid = c.connamespace
		AND pg_catalog.pg_conversion_is_visible(c.oid)
	ORDER BY 1, 2;

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any conversions."
	fi
}

# ?dC

function _list_casts 
{
	echo "[ List of casts ]"

	SELECT pg_catalog.format_type(castsource, NULL) AS "Source type",
		pg_catalog.format_type(casttarget, NULL) AS "Target type",
		CASE WHEN castfunc = 0 THEN '(binary compatible)' ELSE p.proname
		END as "Function",
		CASE WHEN c.castcontext = 'e' THEN 'no'
			WHEN c.castcontext = 'a' THEN 'in assignment' ELSE 'yes'
		END as "Implicit?"
	FROM pg_catalog.pg_cast c LEFT JOIN pg_catalog.pg_proc p
		ON c.castfunc = p.oid
	ORDER BY 1, 2;

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any casts."
	fi
}

# ?dd

function _list_comment 
{
	echo "[ List of comment ]"

	SELECT DISTINCT tt.nspname AS "Schema", tt.name AS "Name", 
		tt.object AS "Object", d.description AS "Description"
	FROM (
		SELECT p.oid as oid, p.tableoid as tableoid,
			n.nspname as nspname,
			CAST(p.proname AS pg_catalog.text) as name,  
			CAST('aggregate' AS pg_catalog.text) as object
		FROM pg_catalog.pg_proc p
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
		WHERE p.proisagg AND pg_catalog.pg_function_is_visible(p.oid)
		UNION ALL
		SELECT p.oid as oid, p.tableoid as tableoid, n.nspname as nspname,
			CAST(p.proname AS pg_catalog.text) as name,  
			CAST('function' AS pg_catalog.text) as object
		FROM pg_catalog.pg_proc p
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
		WHERE p.prorettype <> 'pg_catalog.cstring'::pg_catalog.regtype
			AND (p.proargtypes[0] IS NULL
			OR   p.proargtypes[0] <> 'pg_catalog.cstring'::pg_catalog.regtype)
			AND NOT p.proisagg AND pg_catalog.pg_function_is_visible(p.oid)
		UNION ALL
		SELECT o.oid as oid, o.tableoid as tableoid, n.nspname as nspname,
			CAST(o.oprname AS pg_catalog.text) as name,  
			CAST('operator' AS pg_catalog.text) as object
		FROM pg_catalog.pg_operator o
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = o.oprnamespace
		WHERE pg_catalog.pg_operator_is_visible(o.oid)
		UNION ALL
		SELECT t.oid as oid, t.tableoid as tableoid, n.nspname as nspname,
			pg_catalog.format_type(t.oid, NULL) as name,  
			CAST('data type' AS pg_catalog.text) as object
		FROM pg_catalog.pg_type t
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
		WHERE pg_catalog.pg_type_is_visible(t.oid)
		UNION ALL
		SELECT c.oid as oid, c.tableoid as tableoid, n.nspname as nspname,
			CAST(c.relname AS pg_catalog.text) as name,
			CAST(
				CASE c.relkind 	WHEN 'r' THEN 'table' 
								WHEN 'v' THEN 'view' 
								WHEN 'i' THEN 'index' 
								WHEN 'S' THEN 'sequence' 
				END  AS pg_catalog.text
			) as object
		FROM pg_catalog.pg_class c
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		WHERE c.relkind IN ('r', 'v', 'i', 'S') AND pg_catalog.pg_table_is_visible(c.oid)
		UNION ALL
		SELECT r.oid as oid, r.tableoid as tableoid, n.nspname as nspname,
			CAST(r.rulename AS pg_catalog.text) as name,  
			CAST('rule' AS pg_catalog.text) as object
		FROM pg_catalog.pg_rewrite r
			JOIN pg_catalog.pg_class c ON c.oid = r.ev_class
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		WHERE r.rulename != '_RETURN' AND pg_catalog.pg_table_is_visible(c.oid)
		UNION ALL
		SELECT t.oid as oid, t.tableoid as tableoid, n.nspname as nspname,
			CAST(t.tgname AS pg_catalog.text) as name,  
			CAST('trigger' AS pg_catalog.text) as object
		FROM pg_catalog.pg_trigger t
			JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		WHERE pg_catalog.pg_table_is_visible(c.oid)
	) AS tt
		JOIN pg_catalog.pg_description d 
			ON (tt.oid = d.objoid AND tt.tableoid = d.classoid AND d.objsubid = 0)
	ORDER BY 1, 2, 3;

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any comments."
	fi
}

# ?dD

function _list_domains 
{
	echo "[ List of domains ]"

	SELECT n.nspname as "Schema",
		t.typname as "Name",
		pg_catalog.format_type(t.typbasetype, t.typtypmod) as "Type",
		CASE WHEN t.typnotnull AND t.typdefault IS NOT NULL THEN 'not null default '||t.typdefault
			WHEN t.typnotnull AND t.typdefault IS NULL THEN 'not null'
			WHEN NOT t.typnotnull AND t.typdefault IS NOT NULL THEN 'default '||t.typdefault
			ELSE ''
		END as "Modifier",
		pg_catalog.pg_get_constraintdef(r.oid, true) as "Check"
	FROM pg_catalog.pg_type t
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
		LEFT JOIN pg_catalog.pg_constraint r ON t.oid = r.contypid
	WHERE t.typtype = 'd' AND pg_catalog.pg_type_is_visible(t.oid)
	ORDER BY 1, 2;

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any domains."
    fi
}

# ?df

function _list_functions()
{
	echo "[ List of functions ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema",
		p.proname as "Name",
		CASE WHEN p.proretset THEN 'setof ' ELSE '' END ||
		pg_catalog.format_type(p.prorettype, NULL) as "Result data type",
		CASE WHEN proallargtypes IS NOT NULL THEN
		pg_catalog.array_to_string(ARRAY(
		SELECT
			CASE
			WHEN p.proargmodes[s.i] = 'i' THEN ''
			WHEN p.proargmodes[s.i] = 'o' THEN 'OUT '
			WHEN p.proargmodes[s.i] = 'b' THEN 'INOUT '
			END ||
			CASE
			WHEN COALESCE(p.proargnames[s.i], '') = '' THEN ''
			ELSE p.proargnames[s.i] || ' '
			END ||
			pg_catalog.format_type(p.proallargtypes[s.i], NULL)
		FROM
			pg_catalog.generate_series(1, pg_catalog.array_upper(p.proallargtypes, 1)) AS s(i)
		), ', ')
		ELSE
		pg_catalog.array_to_string(ARRAY(
		SELECT
			CASE
			WHEN COALESCE(p.proargnames[s.i+1], '') = '' THEN ''
			ELSE p.proargnames[s.i+1] || ' '
			END ||
			pg_catalog.format_type(p.proargtypes[s.i], NULL)
		FROM
			pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)
		), ', ')
		END AS "Argument data types"
	FROM pg_catalog.pg_proc p
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
	WHERE p.prorettype <> 'pg_catalog.cstring'::pg_catalog.regtype
		AND (p.proargtypes[0] IS NULL
		OR   p.proargtypes[0] <> 'pg_catalog.cstring'::pg_catalog.regtype)
		AND NOT p.proisagg
		AND pg_catalog.pg_function_is_visible(p.oid)
	ORDER BY 1, 2, 3, 4;

	else

	SELECT n.nspname as "Schema", p.proname as "Name",
		CASE WHEN p.proretset THEN 'setof ' ELSE '' END ||
		pg_catalog.format_type(p.prorettype, NULL) as "Result data type",
		CASE WHEN proallargtypes IS NOT NULL THEN
		pg_catalog.array_to_string(ARRAY(
		SELECT
			CASE
			WHEN p.proargmodes[s.i] = 'i' THEN ''
			WHEN p.proargmodes[s.i] = 'o' THEN 'OUT '
			WHEN p.proargmodes[s.i] = 'b' THEN 'INOUT '
			END ||
			CASE
			WHEN COALESCE(p.proargnames[s.i], '') = '' THEN ''
			ELSE p.proargnames[s.i] || ' '
			END ||
			pg_catalog.format_type(p.proallargtypes[s.i], NULL)
		FROM
			pg_catalog.generate_series(1, pg_catalog.array_upper(p.proallargtypes, 1)) AS s(i)
		), ', ')
		ELSE
		pg_catalog.array_to_string(ARRAY(
		SELECT
			CASE
			WHEN COALESCE(p.proargnames[s.i+1], '') = '' THEN ''
			ELSE p.proargnames[s.i+1] || ' '
			END ||
			pg_catalog.format_type(p.proargtypes[s.i], NULL)
		FROM
			pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)
		), ', ')
		END AS "Argument data types",
		CASE
			WHEN p.provolatile = 'i' THEN 'immutable'
			WHEN p.provolatile = 's' THEN 'stable'
			WHEN p.provolatile = 'v' THEN 'volatile'
		END as "Volatility",
		r.rolname as "Owner",
		l.lanname as "Language",
		p.prosrc as "Source code",
		pg_catalog.obj_description(p.oid, 'pg_proc') as "Description"
	FROM pg_catalog.pg_proc p
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
		LEFT JOIN pg_catalog.pg_language l ON l.oid = p.prolang
		JOIN pg_catalog.pg_roles r ON r.oid = p.proowner
	WHERE p.prorettype <> 'pg_catalog.cstring'::pg_catalog.regtype
		AND (p.proargtypes[0] IS NULL
		OR   p.proargtypes[0] <> 'pg_catalog.cstring'::pg_catalog.regtype)
		AND NOT p.proisagg
		AND pg_catalog.pg_function_is_visible(p.oid)
	ORDER BY 1, 2, 3, 4;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any functions."
	fi
}  

# ?dF

function _list_textconfig()
{
	echo "[ List of text search configurations ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.cfgname as "Name",
		pg_catalog.obj_description(c.oid, 'pg_ts_config') as "Description"
	FROM pg_catalog.pg_ts_config c
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace
	WHERE pg_catalog.pg_ts_config_is_visible(c.oid)
	ORDER BY 1, 2;

	else

	exec_sql -q "begin transaction;"

	exec_sql -q "declare cur cursor for \
	SELECT c.oid, c.cfgname, n.nspname, p.prsname, np.nspname as pnspname \
	FROM pg_catalog.pg_ts_config c \
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace, \
		pg_catalog.pg_ts_parser p \
		LEFT JOIN pg_catalog.pg_namespace np ON np.oid = p.prsnamespace \
	WHERE  p.oid = c.cfgparser \
		AND pg_catalog.pg_ts_config_is_visible(c.oid) \
	ORDER BY 3, 2;";

	if (($SQLCODE == 0)); then
		declares -i x ; let x=0;  while ((x < 100))  
		do
			FETCH IN CUR INTO 
			 :oid,  :cfgname,  :nspname,  :prsname, :nspname;

			if (( SQLCODE == SQL_OK )); then
#
				SELECT (SELECT t.alias 
					FROM pg_catalog.ts_token_type(c.cfgparser) AS t
					WHERE t.tokid = m.maptokentype ) AS "Token",
					pg_catalog.btrim(
					ARRAY( 
						SELECT mm.mapdict::pg_catalog.regdictionary
						FROM pg_catalog.pg_ts_config_map AS mm
						WHERE mm.mapcfg = m.mapcfg AND mm.maptokentype = m.maptokentype
						ORDER BY mapcfg, maptokentype, mapseqno
					) :: pg_catalog.text ,
					'{}') AS "Dictionaries"
				FROM pg_catalog.pg_ts_config AS c, pg_catalog.pg_ts_config_map AS m
				WHERE c.oid = '$oid' AND m.mapcfg = c.oid
				GROUP BY m.mapcfg, m.maptokentype, c.cfgparser
				ORDER BY 1;
				echo ""
#
				let x=x+1
			else
				let x=101
			fi
		done
	fi
	exec_sql -q "end transaction;"
	echo ""

	fi

#	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
#		echo "# Did not find any text search configurations."
#		return;
#	fi
}  

# ?dFd

function _list_textdict()
{
	echo "[ List of text search dictionaries ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", d.dictname as "Name",
		pg_catalog.obj_description(d.oid, 'pg_ts_dict') as "Description"
	FROM pg_catalog.pg_ts_dict d
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.dictnamespace
	WHERE pg_catalog.pg_ts_dict_is_visible(d.oid)
	ORDER BY 1, 2;

	else

	SELECT n.nspname as "Schema", d.dictname as "Name",
		( SELECT COALESCE(nt.nspname, '(null)')::pg_catalog.text || '.' || t.tmplname 
		FROM pg_catalog.pg_ts_template t
			LEFT JOIN pg_catalog.pg_namespace nt ON nt.oid = t.tmplnamespace
		WHERE d.dicttemplate = t.oid ) AS  "Template",
		d.dictinitoption as "Init options",
		pg_catalog.obj_description(d.oid, 'pg_ts_dict') as "Description"
	FROM pg_catalog.pg_ts_dict d
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.dictnamespace
	WHERE pg_catalog.pg_ts_dict_is_visible(d.oid)
	ORDER BY 1, 2;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any text search dictionaries."
	fi
}  

# ?dFt

function _list_texttemple()
{
	echo "[ List of text search templates ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname AS "Schema", t.tmplname AS "Name",
		pg_catalog.obj_description(t.oid, 'pg_ts_template') AS "Description"
	FROM pg_catalog.pg_ts_template t
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.tmplnamespace
	WHERE pg_catalog.pg_ts_template_is_visible(t.oid)
	ORDER BY 1, 2;

	else

	SELECT n.nspname AS "Schema", t.tmplname AS "Name",
		t.tmplinit::pg_catalog.regproc AS "Init",
		t.tmpllexize::pg_catalog.regproc AS "Lexize",
		pg_catalog.obj_description(t.oid, 'pg_ts_template') AS "Description"
	FROM pg_catalog.pg_ts_template t
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.tmplnamespace
	WHERE pg_catalog.pg_ts_template_is_visible(t.oid)
	ORDER BY 1, 2;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any text search templates."
	fi
}  

# ?dFp

function _list_textparser()
{
	echo "[ List of text search parsers ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", p.prsname as "Name",
		pg_catalog.obj_description(p.oid, 'pg_ts_parser') as "Description"
	FROM pg_catalog.pg_ts_parser p
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace
	WHERE pg_catalog.pg_ts_parser_is_visible(p.oid)
	ORDER BY 1, 2;

	else

	SELECT p.oid, n.nspname, p.prsname
	INTO    :oid,  :nspname,  :prsname
	FROM pg_catalog.pg_ts_parser p
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace
	WHERE pg_catalog.pg_ts_parser_is_visible(p.oid)
	ORDER BY 1, 2;

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any text search parsers."
		return;
	fi

	SELECT 'Start parse' AS "Method",
		p.prsstart::pg_catalog.regproc AS "Function",
		pg_catalog.obj_description(p.prsstart, 'pg_proc') as "Description"
	FROM pg_catalog.pg_ts_parser p
	WHERE p.oid = '$oid'
	UNION ALL
	SELECT 'Get next token',
		p.prstoken::pg_catalog.regproc,
		pg_catalog.obj_description(p.prstoken, 'pg_proc')
	FROM pg_catalog.pg_ts_parser p
	WHERE p.oid = '$oid'
	UNION ALL
	SELECT 'End parse',
		p.prsend::pg_catalog.regproc,
		pg_catalog.obj_description(p.prsend, 'pg_proc')
	FROM pg_catalog.pg_ts_parser p
	WHERE p.oid = '$oid'
	UNION ALL
	SELECT 'Get headline',
		p.prsheadline::pg_catalog.regproc,
		pg_catalog.obj_description(p.prsheadline, 'pg_proc')
	FROM pg_catalog.pg_ts_parser p
	WHERE p.oid = '$oid'
	UNION ALL
	SELECT 'Get token types',
		p.prslextype::pg_catalog.regproc,
		pg_catalog.obj_description(p.prslextype, 'pg_proc')
	FROM pg_catalog.pg_ts_parser p
	WHERE p.oid = '$oid';

	echo ""
	SELECT t.alias as "Token name", t.description as "Description"
	FROM pg_catalog.ts_token_type( '3722'::pg_catalog.oid ) as t
	ORDER BY 1;

	fi
}  

# ?dn

function _list_schemas()
{
	echo "[ List of schemas ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname AS "Name", r.rolname AS "Owner"
	FROM pg_catalog.pg_namespace n JOIN pg_catalog.pg_roles r ON n.nspowner=r.oid
	WHERE   (n.nspname !~ '^pg_temp_' OR
		n.nspname = (pg_catalog.current_schemas(true))[1])
	ORDER BY 1;

	else

	SELECT n.nspname AS "Name", r.rolname AS "Owner",
			n.nspacl as "Access privileges",  
			pg_catalog.obj_description(n.oid, 'pg_namespace') as "Description"
	FROM pg_catalog.pg_namespace n JOIN pg_catalog.pg_roles r ON n.nspowner=r.oid
	WHERE   (n.nspname !~ '^pg_temp_' OR
			n.nspname = (pg_catalog.current_schemas(true))[1])
	ORDER BY 1;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any schames."
    fi
}

# ?do

function _list_operators 
{
	echo "[ List of operators ]"

	SELECT n.nspname as "Schema",
		o.oprname AS "Name",
		CASE WHEN o.oprkind='l' THEN NULL ELSE pg_catalog.format_type(o.oprleft, NULL) 
		END AS "Left arg type",
		CASE WHEN o.oprkind='r' THEN NULL ELSE pg_catalog.format_type(o.oprright, NULL) 
		END AS "Right arg type",
		pg_catalog.format_type(o.oprresult, NULL) AS "Result type",
		coalesce(pg_catalog.obj_description(o.oid, 'pg_operator'),
		pg_catalog.obj_description(o.oprcode, 'pg_proc')) AS "Description"
	FROM pg_catalog.pg_operator o
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = o.oprnamespace
	WHERE pg_catalog.pg_operator_is_visible(o.oid)
	ORDER BY 1, 2, 3, 4;

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any operations."
    fi
}  

# ?dl, ?lo_list

function _lo_list 
{
	echo "[ List of large objects ]"

	SELECT 	loid as "ID",
			pg_catalog.obj_description(loid, 'pg_largeobject') as "Description"
	FROM (SELECT DISTINCT loid FROM pg_catalog.pg_largeobject) x
	ORDER BY 1;

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any large objects."
    fi
}

# ?dT

function _list_types()
{
	echo "[ List of data types ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema",
		pg_catalog.format_type(t.oid, NULL) AS "Name",
		pg_catalog.obj_description(t.oid, 'pg_type') as "Description"
	FROM pg_catalog.pg_type t
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	WHERE (t.typrelid = 0 OR 
		(SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) 
		AND t.typname !~ '^_' AND pg_catalog.pg_type_is_visible(t.oid)
	ORDER BY 1, 2;

	else

	SELECT n.nspname as "Schema",
		pg_catalog.format_type(t.oid, NULL) AS "Name",
		t.typname AS "Internal name",
		CASE WHEN t.typrelid != 0 THEN CAST('tuple' AS pg_catalog.text)
			WHEN t.typlen < 0 THEN CAST('var' AS pg_catalog.text)
			ELSE CAST(t.typlen AS pg_catalog.text)
		END AS "Size",
		pg_catalog.obj_description(t.oid, 'pg_type') as "Description"
	FROM pg_catalog.pg_type t
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	WHERE (t.typrelid = 0 OR 
		(SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) 
		AND t.typname !~ '^_' AND pg_catalog.pg_type_is_visible(t.oid)
	ORDER BY 1, 2;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any data types."
	fi
}  


#****************************************************
#	                  Status 
#****************************************************

# ?dbc, ?dbconnection

function _show_connection 
{
	exec_sql -Lm 
} 

# ?opt, ?option

function _show_exec_sql_option 
{
	echo "# EXEC_SQL_OPTION"
	echo "  Usage:"
	echo "  set EXEC_SQL_OPTION DEFAULT ;   --- reset DEFAULT"
	echo "  set EXEC_SQL_OPTION CGI ;       --- set CGI mode"
	echo "  set <option_name>[=value] ;"
	echo " "
	echo "  ex)"
	echo "  SET OPTION_ECHO; or SET OPTION_ECHO=ON; or SET OPTION_ECHO=TRUE;"
	echo "  SET OPTION_BOTTOM=OFF; or SET OPTION_BOTTOM=FALSE;"
	echo "  set OPTION_SEPARATOR=',';"
	echo "  set OPTION_NULLSTRING=\"\\N\";"
	echo " "
	echo "+-------------------+-------------------------+-------+---------------"
	echo "|   <option_name>   |      Comment            |DEFAULT| Current Value "
	echo "+-------------------+-------------------------+-------+---------------"
	echo "| OPTION_ECHO       | turn on/off ECHO query  | OFF   | $OPTION_ECHO"
	echo "| OPTION_QUIET      | turn on/off QUIET mode  | OFF   | $OPTION_QUIET"
	echo "| OPTION_HEADER     | turn on/off TOP_header  | ON    | $OPTION_HEADER"
	echo "| OPTION_BOTTOM     | turn on/off BOTTOM_print| ON    | $OPTION_BOTTOM"
	echo "| OPTION_ALIGNMENT  | turn on/off ALIGNMENT   | ON    | $OPTION_ALIGNMENT"
	echo "| OPTION_FRAME      | turn on/off OUTER_FRAME | OFF   | $OPTION_FRAME"
	echo "| OPTION_EXPANDED   | turn on/off EXPANDED    | OFF   | $OPTION_EXPANDED"
	echo "| OPTION_SEPARATOR  | set SEPARATOR character | ''    | '$OPTION_SEPARATOR'"
	echo "| OPTION_NULLSTRING | set NULL string         | \"\"    | \"$OPTION_NULLSTRING\" "
	echo "| OPTION_ZEROSTRING | set ZERO string         | \"\"    | \"$OPTION_ZEROSTRING\" "
	echo "| OPTION_CAPTION    | set CAPTION             | \"\"    | \"$OPTION_CAPTION\" "
	echo "+-------------------+-------------------------+-------+---------------"
	echo ""
	echo "[ CGI_mode / HTML_output_mode ]"
	echo "+-------------------+-------------------------+-------+---------------"
	echo "|   <option_name>   |      Comment            |DEFAULT| Current Value "
	echo "+-------------------+-------------------------+-------+---------------"
	echo "| OPTION_HTML       | turn on/off HTML mode   | OFF   | $OPTION_HTML"
	echo "| OPTION_TABLETAG   | set HTML table tag      | \"\"    | \"$OPTION_TABLETAG\" "
	echo "| OPTION_HEADERTR   | set HTML header <TR>    | \"\"    | \"$OPTION_HEADERTR\" "
	echo "| OPTION_HEADERTH   | set HTML header <TH>    | \"\"    | \"$OPTION_HEADERTH\" "
	echo "| OPTION_BODYTAG    | set HTML body <TD> tag  | \"\"    | \"$OPTION_BODYTAG\" "
	echo "| OPTION_INPUTTAG   | turn on/off INPUT tag   | OFF   | $OPTION_INPUTTAG"
	echo "| OPTION_INPUTSIZE  | set HTML input tag SIZE | \"\"    | \"$OPTION_INPUTSIZE\""
	echo "+-------------------+-------------------------+-------+---------------"
}

# ?sta, ?status

function _show_sqlcode  # status after SQL execution
{
	exec_sql -s
}

# ?ver, ?version

function _show_version 
{
	OPTION_WORK=$OPTION_QUIET
	set OPTION_QUIET;
	select version() into :version;
	set OPTION_QUIET=$OPTION_WORK;

	echo "# $version"
	exec_sql -v
	echo "# Pgbashrc Version $PGBASHRC_VERSION"
} 

#****************************************************
#	                    Help 
#****************************************************

# ??

function _help_usage 
{
	echo "# Usage:"
	echo "  Type '?'  for help with pgbash commands."
	echo "  Type 'exit' or 'Ctrl+D' to terminate Pgbash."
	echo ""
}

# ??sql

function _help_sql_usage
{
	echo "# SQL usage:"
	echo "  Type '[timespec] SQL; [pipeline][redirection][&]'"
	echo "  ex)"
	echo "  select * from test limit 300;"
	echo "  select * from test; > /tmp/test.dat"
	echo "  select * from test; >> /tmp/test.dat &"
	echo "  select * from test; | more"
	echo "  time  select * from test limit 300;"
	echo " "
	echo "  select code, name into :code, :name from test;"
	echo "  if [ \$code = '101' ]; then"
	echo "      echo \"code=\$code name=\$name\""
	echo "  fi"
	echo " "
	echo "  begin;"
	echo "  declare cur cursor for select code,name from test order by code;"
	echo "  while (( \$SQLCODE == \$SQL_OK )); do"
	echo "     fetch in cur into :code, :name;"
	echo "     if (( \$SQLCODE < 0 || \$SQLCODE == \$SQL_NOT_FOUND)); then"
	echo "        break"
	echo "     else"
	echo "         echo \"code=\$code  name=\$name\"  "
	echo "     fi"
	echo "  done"
	echo "  end;"
}

# ??connect

function _help_connection
{
	echo "# Connection:"
	echo ""
	echo "  1. Connect to database."
	echo "     Type 'connect to DB[@SERVERNAME][:PORT] [as CONNECT_NAME] [user UID [PASSWD|NULL]];'"
	echo "          ,or"
	echo "          '?con[nect] DB[@SERVERNAME][:PORT]    [CONNECT_NAME       [UID [PASSWD|NULL]]]'"
	echo "           or"
	echo "          'connect to DEFAULT;'"
	echo "     ex)"
	echo "     connect to DEFAULT; <-- DB user is LoginID, Password is NULL"
	echo "     connect to db1;"
	echo "     connect to testdb:5433         as db2;"
	echo "     connect to db3@SERVERNAME      as db3 user user1 xxxxxx;"
	echo "     connect to db4@SERVERNAME:5434 as db4 user user1 xxxxxx;"
	echo " "
	echo "  2. Set connection, if some databases are connected. "
	echo "     Type 'set connection   CONNECT_NAME;'"
	echo "          ,or"
	echo "          '?set[connection] CONNECT_NAME'"
	echo "          ,or"
	echo "          The last connection is used, if 'set connection' has not been done."
	echo "     ex)"
	echo "     connect to db1;"
	echo "     connect to db2;"
	echo "     set connection db1;"
	echo "     select * from test;"
	echo " "
	echo "  3. Execute SQL."
	echo "     'connect to DEFAULT;' is automatically done before executing SQL,"
	echo "     if database connection has not been done."
	echo " "
	echo "  4. Disconnect database."
	echo "     Type 'disconnect    {CONNECT_NAME | ALL};'"
	echo "          ,or"
	echo "          '?dis[connect] {CONNECT_NAME | ALL}'"
	echo "          ,or"
	echo "     Connections are automatically closed when Pgbash is terminated."
	echo "     ex)"
	echo "     disconnect db1;"
	echo "     disconnect all;"
	echo " "
}

# ??sqlcode

function _help_sqlcode 
{
	echo "# SQLCODE"
	echo "  ex)"
	echo "  begin;"
	echo "  declare cur cursor for select code,name from test order by code;"
	echo "  while (( \$SQLCODE == \$SQL_OK )); do"
	echo "     fetch in cur into :code, :name;"
	echo "     if (( \$SQLCODE < 0 || \$SQLCODE == \$SQL_NOT_FOUND)); then"
	echo "        break"
	echo "     else"
	echo "         echo \"code=\$code  name=\$name\"  "
	echo "     fi"
	echo "  done"
	echo "  end;"
	echo ""
	echo "-------------------------+-------------------------------------------+--------"
	echo "       Value Name        |               Comment                     | Value"
	echo "-------------------------+-------------------------------------------+--------"
	echo " \$SQL_OK                 | normal end.                               |$SQL_OK"
	echo " \$SQL_NOT_FOUND          | EOF(End Of File).                         |$SQL_NOT_FOUND"
	echo " \$SQL_OUT_OF_MEMORY      | out of memory.                            |$SQL_OUT_OF_MEMORY"
	echo " \$SQL_SYSTEM_ERROR       | system error.                             |$SQL_SYSTEM_ERROR"
	echo " \$SQL_TOO_MANY_ARGUMENTS | too many arguments in fetch_stmt.         |$SQL_TOO_MANY_ARGUMENTS"
	echo " \$SQL_TOO_FEW_ARGUMENTS  | too few  arguments in fetch_stmt.         |$SQL_TOO_FEW_ARGUMENTS"
	echo " \$SQL_CONNECT_ERROR      | database connection error.                |$SQL_CONNECT_ERROR"   
	echo " \$SQL_INT_FORMAT         | int format error.                         |$SQL_INT_FORMAT"
	echo " \$SQL_UINT_FORMAT        | uint format error.                        |$SQL_UINT_FORMAT"
	echo " \$SQL_FLOAT_FORMAT       | float format error.                       |$SQL_FLOAT_FORMAT"
	echo " \$SQL_NUMERIC_FORMAT     | numeric format error.                     |$SQL_NUMERIC_FORMAT"
	echo " \$SQL_INTERVAL_FORMAT    | interval format error.                    |$SQL_INTERVAL_FORMAT"
	echo " \$SQL_DATE_FORMAT        | date format error.                        |$SQL_DATE_FORMAT"
	echo " \$SQL_TIMESTAMP_FORMAT   | timestamp format error.                   |$SQL_TIMESTAMP_FORMAT"
	echo " \$SQL_CONVERT_BOOL       | convert bool error.                       |$SQL_CONVERT_BOOL"
	echo " \$SQL_EMPTY              | empty.                                    |$SQL_EMPTY"
	echo " \$SQL_MISSING_INDICATOR  | missing_indicator.                        |$SQL_MISSING_INDICATOR"
	echo " \$SQL_NO_ARRAY           | no array.                                 |$SQL_NO_ARRAY"
	echo " \$SQL_DATA_NOT_ARRAY     | data not array.                           |$SQL_DATA_NOT_ARRAY"
	echo " \$SQL_ARRAY_INSERT       | array insert error.                       |$SQL_ARRAY_INSERT"
	echo " \$SQL_NO_CONN            | no connection.                            |$SQL_NO_CONN"
	echo " \$SQL_NOT_CONN           |can not connection.                        |$SQL_NOT_CONN"
	echo " \$SQL_INVALID_STMT       | invalid statements.                       |$SQL_INVALID_STMT" 
	echo " \$SQL_READONLY_SHELLVAR  | can not set read-only shell variable.     |$SQL_READONLY_SHELLVAR"
	echo " \$SQL_DB_NOT_OPEN        | database not open.                        |$SQL_DB_NOT_OPEN"
	echo " \$SQL_CNAME_NOT_FOUND    | connect-name not found.                   |$SQL_CNAME_NOT_FOUND"
	echo " \$SQL_CNAME_ALREADY_USE  | connect-name already exist.               |$SQL_CNAME_ALREADY_USE"
	echo " \$SQL_INVALID_COMMAND    | invalid command.                          |$SQL_INVALID_COMMAND"
	echo " \$SQL_INVALID_DATA       | invalid data.                             |$SQL_INVALID_DATA"

	echo " \$SQL_UNKNOWN_DESCRIPTOR | unknown descriptor.                       |$SQL_UNKNOWN_DESCRIPTOR"
	echo " \$SQL_INVALID_DESC_INDEX | invalid descriptor index.                 |$SQL_INVALID_DESC_INDEX"
	echo " \$SQL_UNKNOWN_DESC_ITEM  | unknown descriptor item.                  |$SQL_UNKNOWN_DESC_ITEM"
	echo " \$SQL_VAR_NOT_NUMERIC    | variable not numeric.                     |$SQL_VAR_NOT_NUMERIC"
	echo " \$SQL_VAR_NOT_CHAR       | variable not charater.                    |$SQL_VAR_NOT_CHAR"

	echo " \$SQL_BAD_RESPONSE       | bad response(backend maybe died).         |$SQL_BAD_RESPONSE"
	echo " \$SQL_EMPTY_QUERY        | empty query (backend lost query).         |$SQL_EMPTY_QUERY"
	echo " \$SQL_CONNECTION_BAD     | connection bad(disconnect backend)        |$SQL_FATAL_ERROR"
	echo " \$SQL_FATAL_ERROR        | query fatal error   (SQL error on backend)|$SQL_FATAL_ERROR"
	echo " \$SQL_NONFATAL_ERROR     | query nonfatal error(SQL error on backend)|$SQL_NONFATAL_ERROR"
	echo " \$SQL_NULL               | indicator is NULL.                        |$SQL_NULL"
	echo "-------------------------+-------------------------------------------+--------"
}

# ??h, ??h SQL

function	_help_sql
{
	case "$*" in

	"abort" | "ABORT" )
	echo "Command:     ABORT"
	echo "Description: abort the current transaction"
	echo "Syntax:"
	echo "ABORT [ WORK | TRANSACTION ]"
	;;

	"alter aggregate" | "ALTER AGGREGATE" )
	echo "Command:     ALTER AGGREGATE"
	echo "Description: change the definition of an aggregate function"
	echo "Syntax:"
	echo "ALTER AGGREGATE name ( type [ , ... ] ) RENAME TO new_name"
	echo "ALTER AGGREGATE name ( type [ , ... ] ) OWNER TO new_owner"
	echo "ALTER AGGREGATE name ( type [ , ... ] ) SET SCHEMA new_schema"
	;;

	"alter conversion" | "ALTER CONVERSION" )
	echo "Command:     ALTER CONVERSION"
	echo "Description: change the definition of a conversion"
	echo "Syntax:"
	echo "ALTER CONVERSION name RENAME TO newname"
	echo "ALTER CONVERSION name OWNER TO newowner"
	;;

	"alter database" | "ALTER DATABASE" )
	echo "Command:     ALTER DATABASE"
	echo "Description: change a database"
	echo "Syntax:"
	echo "ALTER DATABASE name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo ""
	echo "    CONNECTION LIMIT connlimit"
	echo ""
	echo "ALTER DATABASE name RENAME TO newname"
	echo ""
	echo "ALTER DATABASE name OWNER TO new_owner"
	echo ""
	echo "ALTER DATABASE name SET configuration_parameter { TO | = } { value | DEFAULT }"
	echo "ALTER DATABASE name SET configuration_parameter FROM CURRENT"
	echo "ALTER DATABASE name RESET configuration_parameter"
	echo "ALTER DATABASE name RESET ALL"
	;;

	"alter domain" | "ALTER DOMAIN" )
	echo "Command:     ALTER DOMAIN"
	echo "Description: change the definition of a domain"
	echo "Syntax:"
	echo "ALTER DOMAIN name"
	echo "    { SET DEFAULT expression | DROP DEFAULT }"
	echo "ALTER DOMAIN name"
	echo "    { SET | DROP } NOT NULL"
	echo "ALTER DOMAIN name"
	echo "    ADD domain_constraint"
	echo "ALTER DOMAIN name"
	echo "    DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]"
	echo "ALTER DOMAIN name"
	echo "    OWNER TO new_owner "
	echo "ALTER DOMAIN name"
	echo "    SET SCHEMA new_schema"
	;;

	"alter function" | "ALTER FUNCTION" )
	echo "Command:     ALTER FUNCTION"
	echo "Description: change the definition of a function"
	echo "Syntax:"
	echo "ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    action [ ... ] [ RESTRICT ]"
	echo "ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    RENAME TO new_name"
	echo "ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    OWNER TO new_owner"
	echo "ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    SET SCHEMA new_schema"
	echo ""
	echo "where action is one of:"
	echo ""
	echo "    CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT"
	echo "    IMMUTABLE | STABLE | VOLATILE"
	echo "    [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER"
	echo "    COST execution_cost"
	echo "    ROWS result_rows"
	echo "    SET configuration_parameter { TO | = } { value | DEFAULT }"
	echo "    SET configuration_parameter FROM CURRENT"
	echo "    RESET configuration_parameter"
	echo "    RESET ALL"
	;;

	"alter group" | "ALTER GROUP" )
	echo "Command:     ALTER GROUP"
	echo "Description: change role name or membership"
	echo "Syntax:"
	echo "ALTER GROUP groupname ADD USER username [, ... ]"
	echo "ALTER GROUP groupname DROP USER username [, ... ]"
	echo ""
	echo "ALTER GROUP groupname RENAME TO newname"
	;;

	"alter index" | "ALTER INDEX" )
	echo "Command:     ALTER INDEX"
	echo "Description: change the definition of an index"
	echo "Syntax:"
	echo "ALTER INDEX name RENAME TO new_name"
	echo "ALTER INDEX name SET TABLESPACE tablespace_name"
	echo "ALTER INDEX name SET ( storage_parameter = value [, ... ] )"
	echo "ALTER INDEX name RESET ( storage_parameter [, ... ] )"
	;;

	"alter language" | "ALTER LANGUAGE" )
	echo "Command:     ALTER LANGUAGE"
	echo "Description: change the definition of a procedural language"
	echo "Syntax:"
	echo "ALTER [ PROCEDURAL ] LANGUAGE name RENAME TO newname"
	echo "ALTER [ PROCEDURAL ] LANGUAGE name OWNER TO new_owner"
	;;

	"alter operator class" | "ALTER OPERATOR CLASS" )
	echo "Command:     ALTER OPERATOR CLASS"
	echo "Description: change the definition of an operator class"
	echo "Syntax:"
	echo "ALTER OPERATOR CLASS name USING index_method RENAME TO newname"
	echo "ALTER OPERATOR CLASS name USING index_method OWNER TO newowner"
	;;

	"alter operator" | "ALTER OPERATOR" )
	echo "Command:     ALTER OPERATOR"
	echo "Description: change the definition of an operator"
	echo "Syntax:"
	echo "ALTER OPERATOR name ( { lefttype | NONE } , { righttype | NONE } ) OWNER TO newowner"
	;;

	"alter operator family" | "ALTER OPERATOR FAMILY" )
	echo "Command:     ALTER OPERATOR FAMILY"
	echo "Description: change the definition of an operator family"
	echo "Syntax:"
	echo "ALTER OPERATOR FAMILY name USING index_method ADD"
	echo "  {  OPERATOR strategy_number operator_name ( op_type, op_type ) [ RECHECK ]"
	echo "   | FUNCTION support_number [ ( op_type [ , op_type ] ) ] funcname ( argument_type [, ...] )"
	echo "  } [, ... ]"
	echo "ALTER OPERATOR FAMILY name USING index_method DROP"
	echo "  {  OPERATOR strategy_number ( op_type [ , op_type ] )"
	echo "   | FUNCTION support_number ( op_type [ , op_type ] )"
	echo "  } [, ... ]"
	echo "ALTER OPERATOR FAMILY name USING index_method RENAME TO newname"
	echo "ALTER OPERATOR FAMILY name USING index_method OWNER TO newowner"
	;;

	"alter role" | "ALTER ROLE" )
	echo "Command:     ALTER ROLE"
	echo "Description: change a database role"
	echo "Syntax:"
	echo "ALTER ROLE name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | CONNECTION LIMIT connlimit"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo ""
	echo "ALTER ROLE name RENAME TO newname"
	echo ""
	echo "ALTER ROLE name SET configuration_parameter { TO | = } { value | DEFAULT }"
	echo "ALTER ROLE name SET configuration_parameter FROM CURRENT"
	echo "ALTER ROLE name RESET configuration_parameter"
	echo "ALTER ROLE name RESET ALL"
	;;

	"alter schema" | "ALTER SCHEMA" )
	echo "Command:     ALTER SCHEMA"
	echo "Description: change the definition of a schema"
	echo "Syntax:"
	echo "ALTER SCHEMA name RENAME TO newname"
	echo "ALTER SCHEMA name OWNER TO newowner"
	;;

	"alter sequence" | "ALTER SEQUENCE" )
	echo "Command:     ALTER SEQUENCE"
	echo "Description: change the definition of a sequence generator"
	echo "Syntax:"
	echo "ALTER SEQUENCE name [ INCREMENT [ BY ] increment ]"
	echo "    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]"
	echo "    [ RESTART [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]"
	echo "    [ OWNED BY { table.column | NONE } ]"
	echo "ALTER SEQUENCE name RENAME TO new_name"
	echo "ALTER SEQUENCE name SET SCHEMA new_schema"
	;;

	"alter table" | "ALTER TABLE" )
	echo "Command:     ALTER TABLE"
	echo "Description: change the definition of a table"
	echo "Syntax:"
	echo "ALTER TABLE [ ONLY ] name [ * ]"
	echo "    action [, ... ]"
	echo "ALTER TABLE [ ONLY ] name [ * ]"
	echo "    RENAME [ COLUMN ] column TO new_column"
	echo "ALTER TABLE name"
	echo "    RENAME TO new_name"
	echo "ALTER TABLE name"
	echo "    SET SCHEMA new_schema"
	echo ""
	echo "where action is one of:"
	echo ""
	echo "    ADD [ COLUMN ] column type [ column_constraint [ ... ] ]"
	echo "    DROP [ COLUMN ] column [ RESTRICT | CASCADE ]"
	echo "    ALTER [ COLUMN ] column TYPE type [ USING expression ]"
	echo "    ALTER [ COLUMN ] column SET DEFAULT expression"
	echo "    ALTER [ COLUMN ] column DROP DEFAULT"
	echo "    ALTER [ COLUMN ] column { SET | DROP } NOT NULL"
	echo "    ALTER [ COLUMN ] column SET STATISTICS integer"
	echo "    ALTER [ COLUMN ] column SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }"
	echo "    ADD table_constraint"
	echo "    DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]"
	echo "    DISABLE TRIGGER [ trigger_name | ALL | USER ]"
	echo "    ENABLE TRIGGER [ trigger_name | ALL | USER ]"
	echo "    ENABLE REPLICA TRIGGER trigger_name"
	echo "    ENABLE ALWAYS TRIGGER trigger_name"
	echo "    DISABLE RULE rewrite_rule_name"
	echo "    ENABLE RULE rewrite_rule_name"
	echo "    ENABLE REPLICA RULE rewrite_rule_name"
	echo "    ENABLE ALWAYS RULE rewrite_rule_name"
	echo "    CLUSTER ON index_name"
	echo "    SET WITHOUT CLUSTER"
	echo "    SET WITHOUT OIDS"
	echo "    SET ( storage_parameter = value [, ... ] )"
	echo "    RESET ( storage_parameter [, ... ] )"
	echo "    INHERIT parent_table"
	echo "    NO INHERIT parent_table"
	echo "    OWNER TO new_owner"
	echo "    SET TABLESPACE new_tablespace"
	;;

	"alter tablespace" | "ALTER TABLESPACE" )
	echo "Command:     ALTER TABLESPACE"
	echo "Description: change the definition of a tablespace"
	echo "Syntax:"
	echo "ALTER TABLESPACE name RENAME TO newname"
	echo "ALTER TABLESPACE name OWNER TO newowner"
	;;

	"alter trigger" | "ALTER TRIGGER" )
	echo "Command:     ALTER TRIGGER"
	echo "Description: change the definition of a trigger"
	echo "Syntax:"
	echo "ALTER TRIGGER name ON table RENAME TO newname"
	;;

	"alter text search configuration" | "ALTER TEXT SEARCH CONFIGURATION" )
	echo "Command:     ALTER TEXT SEARCH CONFIGURATION"
	echo "Description: change the definition of a text search configuration"
	echo "Syntax:"
	echo "ALTER TEXT SEARCH CONFIGURATION name"
	echo "    ADD MAPPING FOR token_type [, ... ] WITH dictionary_name [, ... ]"
	echo "ALTER TEXT SEARCH CONFIGURATION name"
	echo "    ALTER MAPPING FOR token_type [, ... ] WITH dictionary_name [, ... ]"
	echo "ALTER TEXT SEARCH CONFIGURATION name"
	echo "    ALTER MAPPING REPLACE old_dictionary WITH new_dictionary"
	echo "ALTER TEXT SEARCH CONFIGURATION name"
	echo "    ALTER MAPPING FOR token_type [, ... ] REPLACE old_dictionary WITH new_dictionary"
	echo "ALTER TEXT SEARCH CONFIGURATION name"
	echo "    DROP MAPPING [ IF EXISTS ] FOR token_type [, ... ]"
	echo "ALTER TEXT SEARCH CONFIGURATION name RENAME TO newname"
	echo "ALTER TEXT SEARCH CONFIGURATION name OWNER TO newowner"
	;;

	"alter text search dictionary" | "ALTER TEXT SEARCH DICTIONARY" )
	echo "Command:     ALTER TEXT SEARCH DICTIONARY"
	echo "Description: change the definition of a text search dictionary"
	echo "Syntax:"
	echo "ALTER TEXT SEARCH DICTIONARY name ("
	echo "    option [ = value ] [, ... ]"
	echo ")"
	echo "ALTER TEXT SEARCH DICTIONARY name RENAME TO newname"
	echo "ALTER TEXT SEARCH DICTIONARY name OWNER TO newowner"
	;;

	"alter text search parser" | "ALTER TEXT SEARCH PARSER" )
	echo "Command:     ALTER TEXT SEARCH PARSER"
	echo "Description: change the definition of a text search parser"
	echo "Syntax:"
	echo "ALTER TEXT SEARCH PARSER name RENAME TO newname"
	;;

	"alter text search template" | "ALTER TEXT SEARCH TEMPLATE" )
	echo "Command:     ALTER TEXT SEARCH TEMPLATE"
	echo "Description: change the definition of a text search template"
	echo "Syntax:"
	echo "ALTER TEXT SEARCH TEMPLATE name RENAME TO newname"
	;;

	"alter type" | "ALTER TYPE" )
	echo "Command:     ALTER TYPE"
	echo "Description: change the definition of a type"
	echo "Syntax:"
	echo "ALTER TYPE name OWNER TO new_owner "
	echo "ALTER TYPE name SET SCHEMA new_schema"
	;;

	"alter user" | "ALTER USER" )
	echo "Command:     ALTER USER"
	echo "Description: change a database role"
	echo "Syntax:"
	echo "ALTER USER name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | CONNECTION LIMIT connlimit"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo ""
	echo "ALTER USER name RENAME TO newname"
	echo ""
	echo "ALTER USER name SET configuration_parameter { TO | = } { value | DEFAULT }"
	echo "ALTER USER name SET configuration_parameter FROM CURRENT"
	echo "ALTER USER name RESET configuration_parameter"
	echo "ALTER USER name RESET ALL"
	;;

	"alter view" | "ALTER VIEW" )
	echo "Command:     ALTER VIEW"
	echo "Description: change the definition of a view"
	echo "Syntax:"
	echo "ALTER VIEW name RENAME TO newname"
	;;

	"analyze" | "ANALYZE" )
	echo "Command:     ANALYZE"
	echo "Description: collect statistics about a database"
	echo "Syntax:"
	echo "ANALYZE [ VERBOSE ] [ table [ ( column [, ...] ) ] ]"
	;;

	"begin" | "BEGIN" )
	echo "Command:     BEGIN"
	echo "Description: start a transaction block"
	echo "Syntax:"
	echo "BEGIN [ WORK | TRANSACTION ] [ transaction_mode [, ...] ]"
	echo ""
	echo "where transaction_mode is one of:"
	echo ""
	echo "    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }"
	echo "    READ WRITE | READ ONLY"
	;;

	"checkpoint" | "CHECKPOINT" )
	echo "Command:     CHECKPOINT"
	echo "Description: force a transaction log checkpoint"
	echo "Syntax:"
	echo "CHECKPOINT"
	;;

	"close" | "CLOSE" )
	echo "Command:     CLOSE"
	echo "Description: close a cursor"
	echo "Syntax:"
	echo "CLOSE { name | ALL }"
	;;

	"cluster" | "CLUSTER" )
	echo "Command:     CLUSTER"
	echo "Description: cluster a table according to an index"
	echo "Syntax:"
	echo "CLUSTER tablename [ USING indexname ]"
	echo "CLUSTER"
	;;

	"comment" | "COMMENT" )
	echo "Command:     COMMENT"
	echo "Description: define or change the comment of an object"
	echo "Syntax:"
	echo "COMMENT ON"
	echo "{"
	echo "  TABLE object_name |"
	echo "  COLUMN table_name.column_name |"
	echo "  AGGREGATE agg_name (agg_type [, ...] ) |"
	echo "  CAST (sourcetype AS targettype) |"
	echo "  CONSTRAINT constraint_name ON table_name |"
	echo "  CONVERSION object_name |"
	echo "  DATABASE object_name |"
	echo "  DOMAIN object_name |"
	echo "  FUNCTION func_name ( [ [ argmode ] [ argname ] argtype [, ...] ] ) |"
	echo "  INDEX object_name |"
	echo "  LARGE OBJECT large_object_oid |"
	echo "  OPERATOR op (leftoperand_type, rightoperand_type) |"
	echo "  OPERATOR CLASS object_name USING index_method |"
	echo "  OPERATOR FAMILY object_name USING index_method |"
	echo "  [ PROCEDURAL ] LANGUAGE object_name |"
	echo "  ROLE object_name |"
	echo "  RULE rule_name ON table_name |"
	echo "  SCHEMA object_name |"
	echo "  SEQUENCE object_name |"
	echo "  TABLESPACE object_name |"
	echo "  TEXT SEARCH CONFIGURATION object_name |"
	echo "  TEXT SEARCH DICTIONARY object_name |"
	echo "  TEXT SEARCH PARSER object_name |"
	echo "  TEXT SEARCH TEMPLATE object_name |"
	echo "  TRIGGER trigger_name ON table_name |"
	echo "  TYPE object_name |"
	echo "  VIEW object_name"
	echo "} IS 'text'"
	;;

	"commit" | "COMMIT" )
	echo "Command:     COMMIT"
	echo "Description: commit the current transaction"
	echo "Syntax:"
	echo "COMMIT [ WORK | TRANSACTION ]"
	;;

	"commit prepared" | "COMMIT PREPARED" )
	echo "Command:     COMMIT PREPARED"
	echo "Description: commit a transaction that was earlier prepared for two-phase commit"
	echo "Syntax:"
	echo "COMMIT PREPARED transaction_id"
	;;

	"copy" | "COPY" )
	echo "Command:     COPY"
	echo "Description: copy data between a file and a table"
	echo "Syntax:"
	echo "COPY tablename [ ( column [, ...] ) ]"
	echo "    FROM { 'filename' | STDIN }"
	echo "    [ [ WITH ] "
	echo "          [ BINARY ]"
	echo "          [ OIDS ]"
	echo "          [ DELIMITER [ AS ] 'delimiter' ]"
	echo "          [ NULL [ AS ] 'null string' ]"
	echo "          [ CSV [ HEADER ]"
	echo "                [ QUOTE [ AS ] 'quote' ] "
	echo "                [ ESCAPE [ AS ] 'escape' ]"
	echo "                [ FORCE NOT NULL column [, ...] ]"
	echo ""
	echo "COPY { tablename [ ( column [, ...] ) ] | ( query ) }"
	echo "    TO { 'filename' | STDOUT }"
	echo "    [ [ WITH ] "
	echo "          [ BINARY ]"
	echo "          [ OIDS ]"
	echo "          [ DELIMITER [ AS ] 'delimiter' ]"
	echo "          [ NULL [ AS ] 'null string' ]"
	echo "          [ CSV [ HEADER ]"
	echo "                [ QUOTE [ AS ] 'quote' ] "
	echo "                [ ESCAPE [ AS ] 'escape' ]"
	echo "                [ FORCE QUOTE column [, ...] ]"
	;;

	"create aggregate" | "CREATE AGGREGATE" )
	echo "Command:     CREATE AGGREGATE"
	echo "Description: define a new aggregate function"
	echo "Syntax:"
	echo "CREATE AGGREGATE name ( input_data_type [ , ... ] ) ("
	echo "    SFUNC = sfunc,"
	echo "    STYPE = state_data_type"
	echo "    [ , FINALFUNC = ffunc ]"
	echo "    [ , INITCOND = initial_condition ]"
	echo "    [ , SORTOP = sort_operator ]"
	echo ")"
	echo ""
	echo "or the old syntax"
	echo ""
	echo "CREATE AGGREGATE name ("
	echo "    BASETYPE = base_type,"
	echo "    SFUNC = sfunc,"
	echo "    STYPE = state_data_type"
	echo "    [ , FINALFUNC = ffunc ]"
	echo "    [ , INITCOND = initial_condition ]"
	echo "    [ , SORTOP = sort_operator ]"
	echo ")"
	;;

	"create cast" | "CREATE CAST" )
	echo "Command:     CREATE CAST"
	echo "Description: define a new cast"
	echo "Syntax:"
	echo "CREATE CAST (sourcetype AS targettype)"
	echo "    WITH FUNCTION funcname (argtypes)"
	echo "    [ AS ASSIGNMENT | AS IMPLICIT ]"
	echo ""
	echo "CREATE CAST (sourcetype AS targettype)"
	echo "    WITHOUT FUNCTION"
	echo "    [ AS ASSIGNMENT | AS IMPLICIT ]"
	;;

	"create constraint trigger" | "CREATE CONSTRAINT TRIGGER" )
	echo "Command:     CREATE CONSTRAINT TRIGGER"
	echo "Description: define a new constraint trigger"
	echo "Syntax:"
	echo "CREATE CONSTRAINT TRIGGER name"
	echo "    AFTER event [ OR ... ]"
	echo "    ON table_name"
	echo "    [ FROM referenced_table_name ]"
	echo "    { NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }"
	echo "    FOR EACH ROW"
	echo "    EXECUTE PROCEDURE funcname ( arguments )"
	;;

	"create conversion" | "CREATE CONVERSION" )
	echo "Command:     CREATE CONVERSION"
	echo "Description: define a new encoding conversion"
	echo "Syntax:"
	echo "CREATE [ DEFAULT ] CONVERSION name"
	echo "    FOR source_encoding TO dest_encoding FROM funcname"
	;;

	"create database" | "CREATE DATABASE" )
	echo "Command:     CREATE DATABASE"
	echo "Description: create a new database"
	echo "Syntax:"
	echo "CREATE DATABASE name"
	echo "    [ [ WITH ] [ OWNER [=] dbowner ]"
	echo "           [ TEMPLATE [=] template ]"
	echo "           [ ENCODING [=] encoding ]"
	echo "           [ TABLESPACE [=] tablespace ]"
	echo "           [ CONNECTION LIMIT [=] connlimit ] ]"
	;;

	"create domain" | "CREATE DOMAIN" )
	echo "Command:     CREATE DOMAIN"
	echo "Description: define a new domain"
	echo "Syntax:"
	echo "CREATE DOMAIN name [ AS ] data_type"
	echo "    [ DEFAULT expression ]"
	echo "    [ constraint [ ... ] ]"
	echo ""
	echo "where constraint is:"
	echo ""
	echo "[ CONSTRAINT constraint_name ]"
	echo "{ NOT NULL | NULL | CHECK (expression) }"
	;;

	"create function" | "CREATE FUNCTION" )
	echo "Command:     CREATE FUNCTION"
	echo "Description: define a new function"
	echo "Syntax:"
	echo "CREATE [ OR REPLACE ] FUNCTION"
	echo "    name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    [ RETURNS rettype ]"
	echo "  { LANGUAGE langname"
	echo "    | IMMUTABLE | STABLE | VOLATILE"
	echo "    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT"
	echo "    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER"
	echo "    | COST execution_cost"
	echo "    | ROWS result_rows"
	echo "    | SET configuration_parameter { TO value | = value | FROM CURRENT }"
	echo "    | AS 'definition'"
	echo "    | AS 'obj_file', 'link_symbol'"
	echo "  } ..."
	echo "    [ WITH ( attribute [, ...] ) ]"
	;;

	"create group" | "CREATE GROUP" )
	echo "Command:     CREATE GROUP"
	echo "Description: define a new database role"
	echo "Syntax:"
	echo "CREATE GROUP name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo "    | IN ROLE rolename [, ...]"
	echo "    | IN GROUP rolename [, ...]"
	echo "    | ROLE rolename [, ...]"
	echo "    | ADMIN rolename [, ...]"
	echo "    | USER rolename [, ...]"
	echo "    | SYSID uid"
	;;

	"create index" | "CREATE INDEX" )
	echo "Command:     CREATE INDEX"
	echo "Description: define a new index"
	echo "Syntax:"
	echo "CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] name ON table [ USING method ]"
	echo "    ( { column | ( expression ) } [ opclass ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )"
	echo "    [ WITH ( storage_parameter = value [, ... ] ) ]"
	echo "    [ TABLESPACE tablespace ]"
	echo "    [ WHERE predicate ]"
	;;

	"create language" | "CREATE LANGUAGE" )
	echo "Command:     CREATE LANGUAGE"
	echo "Description: define a new procedural language"
	echo "Syntax:"
	echo "CREATE [ PROCEDURAL ] LANGUAGE name"
	echo "CREATE [ TRUSTED ] [ PROCEDURAL ] LANGUAGE name"
	echo "    HANDLER call_handler [ VALIDATOR valfunction ]"
	;;

	"create operator class" | "CREATE OPERATOR CLASS" )
	echo "Command:     CREATE OPERATOR CLASS"
	echo "Description: define a new operator class"
	echo "Syntax:"
	echo "CREATE OPERATOR CLASS name [ DEFAULT ] FOR TYPE data_type"
	echo "  USING index_method [ FAMILY family_name ] AS"
	echo "  {  OPERATOR strategy_number operator_name [ ( op_type, op_type ) ] [ RECHECK ]"
	echo "   | FUNCTION support_number [ ( op_type [ , op_type ] ) ] funcname ( argument_type [, ...] )"
	echo "   | STORAGE storage_type"
	echo "  } [, ... ]"
	;;

	"create operator" | "CREATE OPERATOR" )
	echo "Command:     CREATE OPERATOR"
	echo "Description: define a new operator"
	echo "Syntax:"
	echo "CREATE OPERATOR name ("
	echo "    PROCEDURE = funcname"
	echo "    [, LEFTARG = lefttype ] [, RIGHTARG = righttype ]"
	echo "    [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ]"
	echo "    [, RESTRICT = res_proc ] [, JOIN = join_proc ]"
	echo "    [, HASHES ] [, MERGES ]"
	echo ")"
	;;

	"create operator family" | "CREATE OPERATOR FAMILY" )
	echo "Command:     CREATE OPERATOR FAMILY"
	echo "Description: define a new operator family"
	echo "Syntax:"
	echo "CREATE OPERATOR FAMILY name USING index_method"
	;;

	"create role" | "CREATE ROLE" )
	echo "Command:     CREATE ROLE"
	echo "Description: define a new database role"
	echo "Syntax:"
	echo "CREATE ROLE name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | CONNECTION LIMIT connlimit"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo "    | IN ROLE rolename [, ...]"
	echo "    | IN GROUP rolename [, ...]"
	echo "    | ROLE rolename [, ...]"
	echo "    | ADMIN rolename [, ...]"
	echo "    | USER rolename [, ...]"
	echo "    | SYSID uid"
	;;

	"create rule" | "CREATE RULE" )
	echo "Command:     CREATE RULE"
	echo "Description: define a new rewrite rule"
	echo "Syntax:"
	echo "CREATE [ OR REPLACE ] RULE name AS ON event"
	echo "    TO table [ WHERE condition ]"
	echo "    DO [ ALSO | INSTEAD ] { NOTHING | command | ( command ; command ... ) }"
	;;

	"create schema" | "CREATE SCHEMA" )
	echo "Command:     CREATE SCHEMA"
	echo "Description: define a new schema"
	echo "Syntax:"
	echo "CREATE SCHEMA schemaname [ AUTHORIZATION username ] [ schema_element [ ... ] ]"
	echo "CREATE SCHEMA AUTHORIZATION username [ schema_element [ ... ] ]"
	;;

	"create sequence" | "CREATE SEQUENCE" )
	echo "Command:     CREATE SEQUENCE"
	echo "Description: define a new sequence generator"
	echo "Syntax:"
	echo "CREATE [ TEMPORARY | TEMP ] SEQUENCE name [ INCREMENT [ BY ] increment ]"
	echo "    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]"
	echo "    [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]"
	echo "    [ OWNED BY { table.column | NONE } ]"
	;;

	"create table" | "CREATE TABLE" )
	echo "Command:     CREATE TABLE"
	echo "Description: define a new table"
	echo "Syntax:"
	echo "CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name ( ["
	echo "  { column_name data_type [ DEFAULT default_expr ] [ column_constraint [ ... ] ]"
	echo "    | table_constraint"
	echo "    | LIKE parent_table [ { INCLUDING | EXCLUDING } { DEFAULTS | CONSTRAINTS | INDEXES } ] ... }"
	echo "    [, ... ]"
	echo "] )"
	echo "[ INHERITS ( parent_table [, ... ] ) ]"
	echo "[ WITH ( storage_parameter [= value] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]"
	echo "[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]"
	echo "[ TABLESPACE tablespace ]"
	echo ""
	echo "where column_constraint is:"
	echo ""
	echo "[ CONSTRAINT constraint_name ]"
	echo "{ NOT NULL | "
	echo "  NULL | "
	echo "  UNIQUE index_parameters |"
	echo "  PRIMARY KEY index_parameters |"
	echo "  CHECK ( expression ) |"
	echo "  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]"
	echo "    [ ON DELETE action ] [ ON UPDATE action ] }"
	echo "[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]"
	echo ""
	echo "and table_constraint is:"
	echo ""
	echo "[ CONSTRAINT constraint_name ]"
	echo "{ UNIQUE ( column_name [, ... ] ) index_parameters |"
	echo "  PRIMARY KEY ( column_name [, ... ] ) index_parameters |"
	echo "  CHECK ( expression ) |"
	echo "  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]"
	echo "    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] }"
	echo "[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]"
	echo ""
	echo "index_parameters in UNIQUE and PRIMARY KEY constraints are:"
	echo ""
	echo "[ WITH ( storage_parameter [= value] [, ... ] ) ]"
	echo "[ USING INDEX TABLESPACE tablespace ]"
	;;

	"create table as" | "CREATE TABLE AS" )
	echo "Command:     CREATE TABLE AS"
	echo "Description: define a new table from the results of a query"
	echo "Syntax:"
	echo "CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name"
	echo "    [ (column_name [, ...] ) ]"
	echo "    [ WITH ( storage_parameter [= value] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]"
	echo "    [ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]"
	echo "    [ TABLESPACE tablespace ]"
	echo "    AS query"
	;;

	"create tablespace" | "CREATE TABLESPACE" )
	echo "Command:     CREATE TABLESPACE"
	echo "Description: define a new tablespace"
	echo "Syntax:"
	echo "CREATE TABLESPACE tablespacename [ OWNER username ] LOCATION 'directory'"
	;;

	"create trigger" | "CREATE TRIGGER" )
	echo "Command:     CREATE TRIGGER"
	echo "Description: define a new trigger"
	echo "Syntax:"
	echo "CREATE TRIGGER name { BEFORE | AFTER } { event [ OR ... ] }"
	echo "    ON table [ FOR [ EACH ] { ROW | STATEMENT } ]"
	echo "    EXECUTE PROCEDURE funcname ( arguments )"
	;;

	"create text search configuration" | "CREATE TEXT SEARCH CONFIGURATION" )
	echo "Command:     CREATE TEXT SEARCH CONFIGURATION"
	echo "Description: define a new text search configuration"
	echo "Syntax:"
	echo "CREATE TEXT SEARCH CONFIGURATION name ("
	echo "    PARSER = parser_name |"
	echo "    COPY = source_config"
	echo ")"
	;;

	"create text search dictionary" | "CREATE TEXT SEARCH DICTIONARY" )
	echo "Command:     CREATE TEXT SEARCH DICTIONARY"
	echo "Description: define a new text search dictionary"
	echo "Syntax:"
	echo "CREATE TEXT SEARCH DICTIONARY name ("
	echo "    TEMPLATE = template"
	echo "    [, option = value [, ... ]]"
	echo ")"
	;;

	"create text search parser" | "CREATE TEXT SEARCH PARSER" )
	echo "Command:     CREATE TEXT SEARCH PARSER"
	echo "Description: define a new text search parser"
	echo "Syntax:"
	echo "CREATE TEXT SEARCH PARSER name ("
	echo "    START = start_function ,"
	echo "    GETTOKEN = gettoken_function ,"
	echo "    END = end_function ,"
	echo "    LEXTYPES = lextypes_function"
	echo "    [, HEADLINE = headline_function ]"
	echo ")"
	;;

	"create text search template" | "CREATE TEXT SEARCH TEMPLATE" )
	echo "Command:     CREATE TEXT SEARCH TEMPLATE"
	echo "Description: define a new text search template"
	echo "Syntax:"
	echo "CREATE TEXT SEARCH TEMPLATE name ("
	echo "    [ INIT = init_function , ]"
	echo "    LEXIZE = lexize_function"
	echo ")"
	;;

	"create type" | "CREATE TYPE" )
	echo "Command:     CREATE TYPE"
	echo "Description: define a new data type"
	echo "Syntax:"
	echo "CREATE TYPE name AS"
	echo "    ( attribute_name data_type [, ... ] )"
	echo ""
	echo "CREATE TYPE name AS ENUM"
	echo "    ( 'label' [, ... ] )"
	echo ""
	echo "CREATE TYPE name ("
	echo "    INPUT = input_function,"
	echo "    OUTPUT = output_function"
	echo "    [ , RECEIVE = receive_function ]"
	echo "    [ , SEND = send_function ]"
	echo "    [ , TYPMOD_IN = type_modifier_input_function ]"
	echo "    [ , TYPMOD_OUT = type_modifier_output_function ]"
	echo "    [ , ANALYZE = analyze_function ]"
	echo "    [ , INTERNALLENGTH = { internallength | VARIABLE } ]"
	echo "    [ , PASSEDBYVALUE ]"
	echo "    [ , ALIGNMENT = alignment ]"
	echo "    [ , STORAGE = storage ]"
	echo "    [ , DEFAULT = default ]"
	echo "    [ , ELEMENT = element ]"
	echo "    [ , DELIMITER = delimiter ]"
	echo ")"
	echo ""
	echo "CREATE TYPE name"
	;;

	"create user" | "CREATE USER" )
	echo "Command:     CREATE USER"
	echo "Description: define a new database role"
	echo "Syntax:"
	echo "CREATE USER name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | CONNECTION LIMIT connlimit"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo "    | IN ROLE rolename [, ...]"
	echo "    | IN GROUP rolename [, ...]"
	echo "    | ROLE rolename [, ...]"
	echo "    | ADMIN rolename [, ...]"
	echo "    | USER rolename [, ...]"
	echo "    | SYSID uid"
	;;

	"create view" | "CREATE VIEW" )
	echo "Command:     CREATE VIEW"
	echo "Description: define a new view"
	echo "Syntax:"
	echo "CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] VIEW name [ ( column_name [, ...] ) ]"
	echo "    AS query"
	;;

	"deallocate" | "DEALLOCATE" )
	echo "Command:     DEALLOCATE"
	echo "Description: deallocate a prepared statement"
	echo "Syntax:"
	echo "DEALLOCATE [ PREPARE ] { name | ALL }"
	;;

	"declare" | "DECLARE" )
	echo "Command:     DECLARE"
	echo "Description: define a cursor"
	echo "Syntax:"
	echo "DECLARE name [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]"
	echo "    CURSOR [ { WITH | WITHOUT } HOLD ] FOR query"
	;;

	"delete" | "DELETE" )
	echo "Command:     DELETE"
	echo "Description: delete rows of a table"
	echo "Syntax:"
	echo "DELETE FROM [ ONLY ] table [ [ AS ] alias ]"
	echo "    [ USING usinglist ]"
	echo "    [ WHERE condition | WHERE CURRENT OF cursor_name ]"
	echo "    [ RETURNING * | output_expression [ AS output_name ] [, ...] ]"
	;;

	"discard" | "DISCARD" )
	echo "Command:     DISCARD"
	echo "Description: discard session state"
	echo "Syntax:"
	echo "DISCARD { ALL | PLANS | TEMPORARY | TEMP }"
	;;

	"drop aggregate" | "DROP AGGREGATE" )
	echo "Command:     DROP AGGREGATE"
	echo "Description: remove an aggregate function"
	echo "Syntax:"
	echo "DROP AGGREGATE [ IF EXISTS ] name ( type [ , ... ] ) [ CASCADE | RESTRICT ]"
	;;

	"drop cast" | "DROP CAST" )
	echo "Command:     DROP CAST"
	echo "Description: remove a cast"
	echo "Syntax:"
	echo "DROP CAST [ IF EXISTS ] (sourcetype AS targettype) [ CASCADE | RESTRICT ]"
	;;

	"drop conversion" | "DROP CONVERSION" )
	echo "Command:     DROP CONVERSION"
	echo "Description: remove a conversion"
	echo "Syntax:"
	echo "DROP CONVERSION [ IF EXISTS ] name [ CASCADE | RESTRICT ]"
	;;

	"drop database" | "DROP DATABASE" )
	echo "Command:     DROP DATABASE"
	echo "Description: remove a database"
	echo "Syntax:"
	echo "DROP DATABASE [ IF EXISTS ] name"
	;;

	"drop domain" | "DROP DOMAIN" )
	echo "Command:     DROP DOMAIN"
	echo "Description: remove a domain"
	echo "Syntax:"
	echo "DROP DOMAIN [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop function" | "DROP FUNCTION" )
	echo "Command:     DROP FUNCTION"
	echo "Description: remove a function"
	echo "Syntax:"
	echo "DROP FUNCTION [ IF EXISTS ] name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    [ CASCADE | RESTRICT ]"
	;;

	"drop group" | "DROP GROUP" )
	echo "Command:     DROP GROUP"
	echo "Description: remove a database role"
	echo "Syntax:"
	echo "DROP GROUP [ IF EXISTS ] name [, ...]"
	;;

	"drop index" | "DROP INDEX" )
	echo "Command:     DROP INDEX"
	echo "Description: remove an index"
	echo "Syntax:"
	echo "DROP INDEX [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop language" | "DROP LANGUAGE" )
	echo "Command:     DROP LANGUAGE"
	echo "Description: remove a procedural language"
	echo "Syntax:"
	echo "DROP [ PROCEDURAL ] LANGUAGE [ IF EXISTS ] name [ CASCADE | RESTRICT ]"
	;;

	"drop operator class" | "DROP OPERATOR CLASS" )
	echo "Command:     DROP OPERATOR CLASS"
	echo "Description: remove an operator class"
	echo "Syntax:"
	echo "DROP OPERATOR CLASS [ IF EXISTS ] name USING index_method [ CASCADE | RESTRICT ]"
	;;

	"drop operator" | "DROP OPERATOR" )
	echo "Command:     DROP OPERATOR"
	echo "Description: remove an operator"
	echo "Syntax:"
	echo "DROP OPERATOR [ IF EXISTS ] name ( { lefttype | NONE } , { righttype | NONE } ) [ CASCADE | RESTRICT ]"
	;;

	"drop operator family" | "DROP OPERATOR FAMILY" )
	echo "Command:     DROP OPERATOR FAMILY"
	echo "Description: remove an operator family"
	echo "Syntax:"
	echo "DROP OPERATOR FAMILY [ IF EXISTS ] name USING index_method [ CASCADE | RESTRICT ]"
	;;

	"drop owned" | "DROP OWNED" )
	echo "Command:     DROP OWNED"
	echo "Description: remove database objects owned by a database role"
	echo "Syntax:"
	echo "DROP OWNED BY name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop role" | "DROP ROLE" )
	echo "Command:     DROP ROLE"
	echo "Description: remove a database role"
	echo "Syntax:"
	echo "DROP ROLE [ IF EXISTS ] name [, ...]"
	;;

	"drop rule" | "DROP RULE" )
	echo "Command:     DROP RULE"
	echo "Description: remove a rewrite rule"
	echo "Syntax:"
	echo "DROP RULE [ IF EXISTS ] name ON relation [ CASCADE | RESTRICT ]"
	;;

	"drop schema" | "DROP SCHEMA" )
	echo "Command:     DROP SCHEMA"
	echo "Description: remove a schema"
	echo "Syntax:"
	echo "DROP SCHEMA [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop sequence" | "DROP SEQUENCE" )
	echo "Command:     DROP SEQUENCE"
	echo "Description: remove a sequence"
	echo "Syntax:"
	echo "DROP SEQUENCE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop table" | "DROP TABLE" )
	echo "Command:     DROP TABLE"
	echo "Description: remove a table"
	echo "Syntax:"
	echo "DROP TABLE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop tablespace" | "DROP TABLESPACE" )
	echo "Command:     DROP TABLESPACE"
	echo "Description: remove a tablespace"
	echo "Syntax:"
	echo "DROP TABLESPACE [ IF EXISTS ] tablespacename"
	;;

	"drop trigger" | "DROP TRIGGER" )
	echo "Command:     DROP TRIGGER"
	echo "Description: remove a trigger"
	echo "Syntax:"
	echo "DROP TRIGGER [ IF EXISTS ] name ON table [ CASCADE | RESTRICT ]"
	;;

	"drop text search configuration" | "DROP TEXT SEARCH CONFIGURATION" )
	echo "Command:     DROP TEXT SEARCH CONFIGURATION"
	echo "Description: remove a text search configuration"
	echo "Syntax:"
	echo "DROP TEXT SEARCH CONFIGURATION [ IF EXISTS ] name [ CASCADE | RESTRICT ]"
	;;

	"drop text search dictionary" | "DROP TEXT SEARCH DICTIONARY" )
	echo "Command:     DROP TEXT SEARCH DICTIONARY"
	echo "Description: remove a text search dictionary"
	echo "Syntax:"
	echo "DROP TEXT SEARCH DICTIONARY [ IF EXISTS ] name [ CASCADE | RESTRICT ]"
	;;

	"drop text search parser" | "DROP TEXT SEARCH PARSER" )
	echo "Command:     DROP TEXT SEARCH PARSER"
	echo "Description: remove a text search parser"
	echo "Syntax:"
	echo "DROP TEXT SEARCH PARSER [ IF EXISTS ] name [ CASCADE | RESTRICT ]"
	;;

	"drop text search template" | "DROP TEXT SEARCH TEMPLATE" )
	echo "Command:     DROP TEXT SEARCH TEMPLATE"
	echo "Description: remove a text search template"
	echo "Syntax:"
	echo "DROP TEXT SEARCH TEMPLATE [ IF EXISTS ] name [ CASCADE | RESTRICT ]"
	;;

	"drop type" | "DROP TYPE" )
	echo "Command:     DROP TYPE"
	echo "Description: remove a data type"
	echo "Syntax:"
	echo "DROP TYPE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop user" | "DROP USER" )
	echo "Command:     DROP USER"
	echo "Description: remove a database role"
	echo "Syntax:"
	echo "DROP USER [ IF EXISTS ] name [, ...]"
	;;

	"drop view" | "DROP VIEW" )
	echo "Command:     DROP VIEW"
	echo "Description: remove a view"
	echo "Syntax:"
	echo "DROP VIEW [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"end" | "END" )
	echo "Command:     END"
	echo "Description: commit the current transaction"
	echo "Syntax:"
	echo "END [ WORK | TRANSACTION ]"
	;;

	"execute" | "EXECUTE" )
	echo "Command:     EXECUTE"
	echo "Description: execute a prepared statement"
	echo "Syntax:"
	echo "EXECUTE name [ ( parameter [, ...] ) ]"
	;;

	"explain" | "EXPLAIN" )
	echo "Command:     EXPLAIN"
	echo "Description: show the execution plan of a statement"
	echo "Syntax:"
	echo "EXPLAIN [ ANALYZE ] [ VERBOSE ] statement"
	;;

	"fetch" | "FETCH" )
	echo "Command:     FETCH"
	echo "Description: retrieve rows from a query using a cursor"
	echo "Syntax:"
	echo "FETCH [ direction { FROM | IN } ] cursorname"
	echo ""
	echo "where direction can be empty or one of:"
	echo ""
	echo "    NEXT"
	echo "    PRIOR"
	echo "    FIRST"
	echo "    LAST"
	echo "    ABSOLUTE count"
	echo "    RELATIVE count"
	echo "    count"
	echo "    ALL"
	echo "    FORWARD"
	echo "    FORWARD count"
	echo "    FORWARD ALL"
	echo "    BACKWARD"
	echo "    BACKWARD count"
	echo "    BACKWARD ALL"
	;;

	"grant" | "GRANT" )
	echo "Command:     GRANT"
	echo "Description: define access privileges"
	echo "Syntax:"
	echo "GRANT { { SELECT | INSERT | UPDATE | DELETE | REFERENCES | TRIGGER }"
	echo "    [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON [ TABLE ] tablename [, ...]"
	echo "    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { { USAGE | SELECT | UPDATE }"
	echo "    [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON SEQUENCE sequencename [, ...]"
	echo "    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON DATABASE dbname [, ...]"
	echo "    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { EXECUTE | ALL [ PRIVILEGES ] }"
	echo "    ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...]"
	echo "    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { USAGE | ALL [ PRIVILEGES ] }"
	echo "    ON LANGUAGE langname [, ...]"
	echo "    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON SCHEMA schemaname [, ...]"
	echo "    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { CREATE | ALL [ PRIVILEGES ] }"
	echo "    ON TABLESPACE tablespacename [, ...]"
	echo "    TO { [ GROUP ] rolename | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT role [, ...] TO rolename [, ...] [ WITH ADMIN OPTION ]"
	;;

	"insert" | "INSERT" )
	echo "Command:     INSERT"
	echo "Description: create new rows in a table"
	echo "Syntax:"
	echo "INSERT INTO table [ ( column [, ...] ) ]"
	echo "    { DEFAULT VALUES | VALUES ( { expression | DEFAULT } [, ...] ) [, ...] | query }"
	echo "    [ RETURNING * | output_expression [ AS output_name ] [, ...] ]"
	;;

	"listen" | "LISTEN" )
	echo "Command:     LISTEN"
	echo "Description: listen for a notification"
	echo "Syntax:"
	echo "LISTEN name"
	;;

	"load" | "LOAD" )
	echo "Command:     LOAD"
	echo "Description: load a shared library file"
	echo "Syntax:"
	echo "LOAD 'filename'"
	;;

	"lock" | "LOCK" )
	echo "Command:     LOCK"
	echo "Description: lock a table"
	echo "Syntax:"
	echo "LOCK [ TABLE ] name [, ...] [ IN lockmode MODE ] [ NOWAIT ]"
	echo ""
	echo "where lockmode is one of:"
	echo ""
	echo "    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE"
	echo "    | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE"
	;;

	"move" | "MOVE" )
	echo "Command:     MOVE"
	echo "Description: position a cursor"
	echo "Syntax:"
	echo "MOVE [ direction { FROM | IN } ] cursorname"
	;;

	"notify" | "NOTIFY" )
	echo "Command:     NOTIFY"
	echo "Description: generate a notification"
	echo "Syntax:"
	echo "NOTIFY name"
	;;

	"prepare" | "PREPARE" )
	echo "Command:     PREPARE"
	echo "Description: prepare a statement for execution"
	echo "Syntax:"
	echo "PREPARE name [ ( datatype [, ...] ) ] AS statement"
	;;

	"prepare transaction" | "PREPARE TRANSACTION" )
	echo "Command:     PREPARE TRANSACTION"
	echo "Description: prepare the current transaction for two-phase commit"
	echo "Syntax:"
	echo "PREPARE TRANSACTION transaction_id"
	;;

	"reassign owned" | "REASSIGN OWNED" )
	echo "Command:     REASSIGN OWNED"
	echo "Description: change the ownership of database objects owned by a database role"
	echo "Syntax:"
	echo "REASSIGN OWNED BY old_role [, ...] TO new_role"
	;;

	"reindex" | "REINDEX" )
	echo "Command:     REINDEX"
	echo "Description: rebuild indexes"
	echo "Syntax:"
	echo "REINDEX { INDEX | TABLE | DATABASE | SYSTEM } name [ FORCE ]"
	;;

	"release savepoint" | "RELEASE SAVEPOINT" )
	echo "Command:     RELEASE SAVEPOINT"
	echo "Description: destroy a previously defined savepoint"
	echo "Syntax:"
	echo "RELEASE [ SAVEPOINT ] savepoint_name"
	;;

	"reset" | "RESET" )
	echo "Command:     RESET"
	echo "Description: restore the value of a run-time parameter to the default value"
	echo "Syntax:"
	echo "RESET configuration_parameter"
	echo "RESET ALL"
	;;

	"revoke" | "REVOKE" )
	echo "Command:     REVOKE"
	echo "Description: remove access privileges"
	echo "Syntax:"
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { { SELECT | INSERT | UPDATE | DELETE | REFERENCES | TRIGGER }"
	echo "    [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON [ TABLE ] tablename [, ...]"
	echo "    FROM { [ GROUP ] rolename | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { { USAGE | SELECT | UPDATE }"
	echo "    [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON SEQUENCE sequencename [, ...]"
	echo "    FROM { [ GROUP ] rolename | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { { CREATE | CONNECT | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON DATABASE dbname [, ...]"
	echo "    FROM { [ GROUP ] rolename | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { EXECUTE | ALL [ PRIVILEGES ] }"
	echo "    ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...]"
	echo "    FROM { [ GROUP ] rolename | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { USAGE | ALL [ PRIVILEGES ] }"
	echo "    ON LANGUAGE langname [, ...]"
	echo "    FROM { [ GROUP ] rolename | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON SCHEMA schemaname [, ...]"
	echo "    FROM { [ GROUP ] rolename | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { CREATE | ALL [ PRIVILEGES ] }"
	echo "    ON TABLESPACE tablespacename [, ...]"
	echo "    FROM { [ GROUP ] rolename | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ ADMIN OPTION FOR ]"
	echo "    role [, ...] FROM rolename [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	;;

	"rollback" | "ROLLBACK" )
	echo "Command:     ROLLBACK"
	echo "Description: abort the current transaction"
	echo "Syntax:"
	echo "ROLLBACK [ WORK | TRANSACTION ]"
	;;

	"rollback prepared" | "ROLLBACK PREPARED" )
	echo "Command:     ROLLBACK PREPARED"
	echo "Description: cancel a transaction that was earlier prepared for two-phase commit"
	echo "Syntax:"
	echo "ROLLBACK PREPARED transaction_id"
	;;

	"rollback to savepoint" | "ROLLBACK TO SAVEPOINT" )
	echo "Command:     ROLLBACK TO SAVEPOINT"
	echo "Description: roll back to a savepoint"
	echo "Syntax:"
	echo "ROLLBACK [ WORK | TRANSACTION ] TO [ SAVEPOINT ] savepoint_name"
	;;

	"savepoint" | "SAVEPOINT" )
	echo "Command:     SAVEPOINT"
	echo "Description: define a new savepoint within the current transaction"
	echo "Syntax:"
	echo "SAVEPOINT savepoint_name"
	;;

	"select" | "SELECT" )
	echo "Command:     SELECT"
	echo "Description: retrieve rows from a table or view"
	echo "Syntax:"
	echo "SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]"
	echo "    * | expression [ AS output_name ] [, ...]"
	echo "    [ FROM from_item [, ...] ]"
	echo "    [ WHERE condition ]"
	echo "    [ GROUP BY expression [, ...] ]"
	echo "    [ HAVING condition [, ...] ]"
	echo "    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]"
	echo "    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]"
	echo "    [ LIMIT { count | ALL } ]"
	echo "    [ OFFSET start ]"
	echo "    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ] [...] ]"
	echo ""
	echo "where from_item can be one of:"
	echo ""
	echo "    [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]"
	echo "    ( select ) [ AS ] alias [ ( column_alias [, ...] ) ]"
	echo "    function_name ( [ argument [, ...] ] ) [ AS ] alias [ ( column_alias [, ...] | column_definition [, ...] ) ]"
	echo "    function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )"
	echo "    from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ]"
	;;

	"select into" | "SELECT INTO" )
	echo "Command:     SELECT INTO"
	echo "Description: define a new table from the results of a query"
	echo "Syntax:"
	echo "SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]"
	echo "    * | expression [ AS output_name ] [, ...]"
	echo "    INTO [ TEMPORARY | TEMP ] [ TABLE ] new_table"
	echo "    [ FROM from_item [, ...] ]"
	echo "    [ WHERE condition ]"
	echo "    [ GROUP BY expression [, ...] ]"
	echo "    [ HAVING condition [, ...] ]"
	echo "    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]"
	echo "    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]"
	echo "    [ LIMIT { count | ALL } ]"
	echo "    [ OFFSET start ]"
	echo "    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ] [...] ]"
	;;

	"set" | "SET" )
	echo "Command:     SET"
	echo "Description: change a run-time parameter"
	echo "Syntax:"
	echo "SET [ SESSION | LOCAL ] configuration_parameter { TO | = } { value | 'value' | DEFAULT }"
	echo "SET [ SESSION | LOCAL ] TIME ZONE { timezone | LOCAL | DEFAULT }"
	;;

	"set constraints" | "SET CONSTRAINTS" )
	echo "Command:     SET CONSTRAINTS"
	echo "Description: set constraint checking modes for the current transaction"
	echo "Syntax:"
	echo "SET CONSTRAINTS { ALL | name [, ...] } { DEFERRED | IMMEDIATE }"
	;;

	"set role" | "SET ROLE" )
	echo "Command:     SET ROLE"
	echo "Description: set the current user identifier of the current session"
	echo "Syntax:"
	echo "SET [ SESSION | LOCAL ] ROLE rolename"
	echo "SET [ SESSION | LOCAL ] ROLE NONE"
	echo "RESET ROLE"
	;;

	"set session authorization" | "SET SESSION AUTHORIZATION" )
	echo "Command:     SET SESSION AUTHORIZATION"
	echo "Description: set the session user identifier and the current user identifier of the current session"
	echo "Syntax:"
	echo "SET [ SESSION | LOCAL ] SESSION AUTHORIZATION username"
	echo "SET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT"
	echo "RESET SESSION AUTHORIZATION"
	;;

	"set transaction" | "SET TRANSACTION" )
	echo "Command:     SET TRANSACTION"
	echo "Description: set the characteristics of the current transaction"
	echo "Syntax:"
	echo "SET TRANSACTION transaction_mode [, ...]"
	echo "SET SESSION CHARACTERISTICS AS TRANSACTION transaction_mode [, ...]"
	echo ""
	echo "where transaction_mode is one of:"
	echo ""
	echo "    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }"
	echo "    READ WRITE | READ ONLY"
	;;

	"show" | "SHOW" )
	echo "Command:     SHOW"
	echo "Description: show the value of a run-time parameter"
	echo "Syntax:"
	echo "SHOW name"
	echo "SHOW ALL"
	;;

	"start transaction" | "START TRANSACTION" )
	echo "Command:     START TRANSACTION"
	echo "Description: start a transaction block"
	echo "Syntax:"
	echo "START TRANSACTION [ transaction_mode [, ...] ]"
	echo ""
	echo "where transaction_mode is one of:"
	echo ""
	echo "    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }"
	echo "    READ WRITE | READ ONLY"
	;;

	"truncate" | "TRUNCATE" )
	echo "Command:     TRUNCATE"
	echo "Description: empty a table or set of tables"
	echo "Syntax:"
	echo "TRUNCATE [ TABLE ] name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"unlisten" | "UNLISTEN" )
	echo "Command:     UNLISTEN"
	echo "Description: stop listening for a notification"
	echo "Syntax:"
	echo "UNLISTEN { name | * }"
	;;

	"update" | "UPDATE" )
	echo "Command:     UPDATE"
	echo "Description: update rows of a table"
	echo "Syntax:"
	echo "UPDATE [ ONLY ] table [ [ AS ] alias ]"
	echo "    SET { column = { expression | DEFAULT } |"
	echo "          ( column [, ...] ) = ( { expression | DEFAULT } [, ...] ) } [, ...]"
	echo "    [ FROM fromlist ]"
	echo "    [ WHERE condition | WHERE CURRENT OF cursor_name ]"
	echo "    [ RETURNING * | output_expression [ AS output_name ] [, ...] ]"
	;;

	"vacuum" | "VACUUM" )
	echo "Command:     VACUUM"
	echo "Description: garbage-collect and optionally analyze a database"
	echo "Syntax:"
	echo "VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ table ]"
	echo "VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] ANALYZE [ table [ (column [, ...] ) ] ]"
	;;

	"values" | "VALUES" )
	echo "Command:     VALUES"
	echo "Description: compute a set of rows"
	echo "Syntax:"
	echo "VALUES ( expression [, ...] ) [, ...]"
	echo "    [ ORDER BY sort_expression [ ASC | DESC | USING operator ] [, ...] ]"
	echo "    [ LIMIT { count | ALL } ]"
	echo "    [ OFFSET start ]"
	;;

	* )
	echo "ABORT                            CREATE LANGUAGE                  DROP TEXT SEARCH CONFIGURATION"
	echo "ALTER AGGREGATE                  CREATE OPERATOR CLASS            DROP TEXT SEARCH DICTIONARY"
	echo "ALTER CONVERSION                 CREATE OPERATOR                  DROP TEXT SEARCH PARSER"
	echo "ALTER DATABASE                   CREATE OPERATOR FAMILY           DROP TEXT SEARCH TEMPLATE"
	echo "ALTER DOMAIN                     CREATE ROLE                      DROP TYPE"
	echo "ALTER FUNCTION                   CREATE RULE                      DROP USER"
	echo "ALTER GROUP                      CREATE SCHEMA                    DROP VIEW"
	echo "ALTER INDEX                      CREATE SEQUENCE                  END"
	echo "ALTER LANGUAGE                   CREATE TABLE                     EXECUTE"
	echo "ALTER OPERATOR CLASS             CREATE TABLE AS                  EXPLAIN"
	echo "ALTER OPERATOR                   CREATE TABLESPACE                FETCH"
	echo "ALTER OPERATOR FAMILY            CREATE TRIGGER                   GRANT"
	echo "ALTER ROLE                       CREATE TEXT SEARCH CONFIGURATION INSERT"
	echo "ALTER SCHEMA                     CREATE TEXT SEARCH DICTIONARY    LISTEN"
	echo "ALTER SEQUENCE                   CREATE TEXT SEARCH PARSER        LOAD"
	echo "ALTER TABLE                      CREATE TEXT SEARCH TEMPLATE      LOCK"
	echo "ALTER TABLESPACE                 CREATE TYPE                      MOVE"
	echo "ALTER TRIGGER                    CREATE USER                      NOTIFY"
	echo "ALTER TEXT SEARCH CONFIGURATION  CREATE VIEW                      PREPARE"
	echo "ALTER TEXT SEARCH DICTIONARY     DEALLOCATE                       PREPARE TRANSACTION"
	echo "ALTER TEXT SEARCH PARSER         DECLARE                          REASSIGN OWNED"
	echo "ALTER TEXT SEARCH TEMPLATE       DELETE                           REINDEX"
	echo "ALTER TYPE                       DISCARD                          RELEASE SAVEPOINT"
	echo "ALTER USER                       DROP AGGREGATE                   RESET"
	echo "ALTER VIEW                       DROP CAST                        REVOKE"
	echo "ANALYZE                          DROP CONVERSION                  ROLLBACK"
	echo "BEGIN                            DROP DATABASE                    ROLLBACK PREPARED"
	echo "CHECKPOINT                       DROP DOMAIN                      ROLLBACK TO SAVEPOINT"
	echo "CLOSE                            DROP FUNCTION                    SAVEPOINT"
	echo "CLUSTER                          DROP GROUP                       SELECT"
	echo "COMMENT                          DROP INDEX                       SELECT INTO"
	echo "COMMIT                           DROP LANGUAGE                    SET"
	echo "COMMIT PREPARED                  DROP OPERATOR CLASS              SET CONSTRAINTS"
	echo "COPY                             DROP OPERATOR                    SET ROLE"
	echo "CREATE AGGREGATE                 DROP OPERATOR FAMILY             SET SESSION AUTHORIZATION"
	echo "CREATE CAST                      DROP OWNED                       SET TRANSACTION"
	echo "CREATE CONSTRAINT TRIGGER        DROP ROLE                        SHOW"
	echo "CREATE CONVERSION                DROP RULE                        START TRANSACTION"
	echo "CREATE DATABASE                  DROP SCHEMA                      TRUNCATE"
	echo "CREATE DOMAIN                    DROP SEQUENCE                    UNLISTEN"
	echo "CREATE FUNCTION                  DROP TABLE                       UPDATE"
	echo "CREATE GROUP                     DROP TABLESPACE                  VACUUM"
	echo "CREATE INDEX                     DROP TRIGGER                     VALUES"
	;;

	esac

	echo ""
}
