#####################################################
# pgbashrc-8.2
#
# This file must be copied to '/etc' directory.
#
# You may copy '/etc/pgbashrc' to '~/.pgbashrc', and
# you can modify your ~/.pgbashrc file. Pgbash tends
# to read ~/.pgbashrc first. If it does not exist, 
# Pgbash tents to read /etc/pgbashrc.
#####################################################

PGBASHRC_VERSION=8.2

#----------------------------------------------------
# Prompt           
#----------------------------------------------------
# \u: login user name
# \w: current directory
# \h: host name
#----------------------------------------------------
#PS1="pgbash[\u@\h]\w> "
#PS1="[pgbash]\w> "
#PS1="pgbash[\u]\w> "
PS1="pgbash> "

#****************************************************
#					Help Menu
#****************************************************
function _help_menu {
	echo "Informational"
	echo "  ?              : this help (add '+' for more detail)"
	echo "  ?h [SQL]       : help on syntax of SQL commands"
	echo "  ?l[+]          : list databases"
	echo "  ?d [NAME]      : describe table,view,index, or sequence"
	echo "  ?d{t|i|v|s}[+] : list {tables/indexes/views/sequences}"
	echo "  ?dS[+]         : list system tables"
	echo "  ?da            : list aggregate functions"
	echo "  ?db[+]         : list tablespaces"
	echo "  ?dc            : list conversions"
	echo "  ?dC            : list casts"
	echo "  ?dd            : show comment for object"
	echo "  ?dD            : list domains"
	echo "  ?df[+]         : list functions"
	echo "  ?dn[+]         : list schemas"
	echo "  ?do            : list operators"
	echo "  ?dp            : list table, view, and sequence access privileges, same as ?z"
	echo "  ?dT[+]         : list data_types"
	echo "  ?du            : list roles (users), same as ?dg"
	echo ""
	echo "Large Objects"
	echo "  ?lo_import     : lo_import <INPUT_FILE_NAME> <'COMMENT'>"
	echo "  ?lo_export     : lo_export <LOBOID> <OUTPUT_FILE_NAME>"
	echo "  ?lo_unlink     : lo_unlink <LOBOID> "
	echo "  ?lo_list       : list LARGE OBJECTs, same as ?dl"
	echo ""
	echo "Connection"
	echo "  ?con[nect] DBNAME[@SERVER][:PORT] [CONNECT_NAME [USERID [PASSWORD]]]" 
	echo "                 : connect to new database"
	echo "  ?set[connection] CONNECT_NAME"
	echo "                 : change database connection"
	echo "  ?dis[connect]   {CONNECT_NAME | ALL}"
	echo "                 : disconnect databases"
	echo "  ?encoding [ENCODING]"
	echo "                 : show or set client encoding"
	echo "  ?password USERNAME"
	echo "                 : securely change the password for a user"
	echo "Status"
	echo "  ?dbc[onnection]: show database connection"
	echo "  ?opt[ion]      : show current values of exec_sql_OPTIONs"
	echo "  ?sta[tus]      : show STATUS after executing SQL"
	echo "  ?ver[sion]     : show PostgreSQL and pgbash VERSION"
	echo ""
	echo "Formatting"
	echo "  E{+|-}         : turn on/off ECHO_QUERY sent to the backend"
	echo "  L{+|-}         : turn on/off OUTER_FRAME_print"
	echo "  T{+|-}         : turn on/off TOP_header_print"
	echo "  B{+|-}         : turn on/off BOTTOM_count_print"
	echo "  A{+|-}         : turn on/off ALIGNMENT of plain text"
	echo "  X{+|-}         : turn on/off EXPANDED format"
	echo "  H{+|-}         : turn on/off HTML table format"
	echo "  C+  [string]   : set CAPTION string          or DEFAULT('')"
	echo "  S+  [chr]      : set SEPARATOR  (e.g. ','  ) or DEFAULT('|')"
	echo "  N+  [str]      : set NULL_STRING(e.g. '*N*') or DEFAULT('')"
	echo "  Z+  [str]      : set ZERO_STRING(e.g. '*0*') or DEFAULT('')"
	echo ""
	echo "Pgbash help"
	echo "  ??             : help with pgbash usage"
	echo "  ??connect      : help with CONNECTION usage"
	echo "  ??sql          : help with SQL usage"
	echo "  ??sqlcode      : help with SQLCODE"
	echo "  ??exec_sql     : help with 'exec_sql' usage"
}


#****************************************************
# 				alias / functions
#****************************************************

#--------------------------------------------------
#				Informational
#--------------------------------------------------
alias ?='_help_menu            | more'
alias ?h='_help_sql'

alias ?u='_list_roles          | more'
alias ?dg='_list_roles         | more'
alias ?du='_list_roles         | more'

alias ?l='_list_databases      | more'
alias ?l+='_list_databases "+" | more'

alias ?z='_list_privileges     | more'
alias ?dp='_list_privileges    | more'

function ?d {
	case "$#" in
	0 ) _list_relations  | more   ;;
	* ) _list_relation   $1       ;;
	esac
}

alias ?dt='_list_tables        | more'
alias ?dt+='_list_tables "+"   | more'

alias ?di='_list_indexes       | more'
alias ?di+='_list_indexes "+"  | more'

alias ?dv='_list_views         | more'
alias ?dv+='_list_views "+"    | more'

alias ?ds='_list_sequences     | more'
alias ?ds+='_list_sequences "+"| more'

alias ?dS='_list_systables     | more'
alias ?dS+='_list_systables "+"| more'

alias ?da='_list_aggregates    | more'

alias ?db='_list_tablespaces      | more'
alias ?db+='_list_tablespaces "+" | more'

alias ?dc='_list_conversions   | more'
alias ?dC='_list_casts         | more'
alias ?dd='_list_comment       | more'
alias ?dD='_list_domains       | more'

alias ?df='_list_functions     | more'
alias ?df+='_list_functions "+"| more'

alias ?dn='_list_schemas       | more'
alias ?dn+='_list_schemas "+"  | more'

alias ?do='_list_operators     | more'

alias ?dT='_list_types         | more'
alias ?dT+='_list_types "+"    | more'

#--------------------------------------------------
#				Formatting
#--------------------------------------------------
alias E+='set OPTION_ECHO=TRUE;'
alias E-='set OPTION_ECHO=FALSE;'
alias L+='set OPTION_FRAME=TRUE;'
alias L-='set OPTION_FRAME=FALSE;'
alias X+='set OPTION_EXPANDED=TRUE;'
alias X-='set OPTION_EXPANDED=FALSE;'
alias H+='set OPTION_HTML=TRUE;'
alias H-='set OPTION_HTML=FALSE;'
alias A+='set OPTION_ALIGNMENT=TRUE;'
alias A-='set OPTION_ALIGNMENT=FALSE;'
alias T+='set OPTION_HEADER=TRUE;'
alias T-='set OPTION_HEADER=FALSE;'
alias B+='set OPTION_BOTTOM=TRUE;'
alias B-='set OPTION_BOTTOM=FALSE;'

function C+ {
	case "$#" in
 	0 ) exec_sql "set OPTION_CAPTION;"        ;;
	* ) exec_sql "set OPTION_CAPTION='$1';"   ;;
	esac
}

function S+ {
	case "$#" in
 	0 ) exec_sql "set OPTION_SEPARATOR;"        ;;
	* ) exec_sql "set OPTION_SEPARATOR='$1';"   ;;
	esac
}

function N+ {
	case "$#" in
	0 ) exec_sql "set OPTION_NULLSTRING;"       ;;
	* ) exec_sql "set OPTION_NULLSTRING='$1';"  ;;
	esac
}

function Z+ {
	case "$#" in
	0 ) exec_sql "set OPTION_ZEROSTRING;"       ;;
	* ) exec_sql "set OPTION_ZEROSTRING='$1';"  ;;
	esac
}

#--------------------------------------------------
#				Large Objects
#--------------------------------------------------
alias ?lo_export='_lo_export'
alias ?lo_import='_lo_import'
alias ?lo_unlink='_lo_unlink'
alias ?lo_list='_lo_list'
alias ?dl='_lo_list      | more'

function _lo_export { 
	case "$#" in
	0 ) echo "_lo_export <OID> <FILE_NAME>" ;;
	* ) exec_sql -x lo_export "$1,'$2'"     ;;
	esac
}
function _lo_import { 
	case "$#" in
	0 ) echo "_lo_import <FILE_NAME> <'COMMENT'>" ;;
	* ) exec_sql -x lo_import "'$1','$2'"         ;;
	esac
}
function _lo_unlink { 
	case "$#" in
	0 ) echo "_lo_unlink <OID>"   ;;
	* ) exec_sql -x lo_unlink "$1" ;;
	esac
}

#----------------------------------------------------
# 				Connection
#----------------------------------------------------
alias ?con='_connect'
alias ?connect='_connect'
function _connect {
	case "$#" in
	1) exec_sql "connect to $1"
	   _disp_connection		;;
	2) exec_sql "connect to $1 as $2"
	   _disp_connection		;;
	3) exec_sql "connect to $1 as $2 user $3"
	   _disp_connection		;;
	4) exec_sql "connect to $1 as $2 user $3 $4"
	   _disp_connection		;;
	*) echo "?con[nect] DBNAME[@SERVER][:PORT] [CONNECT_NAME [USERID [PASSWD]]]"	;;
	esac
}

alias ?set='_setconnection'
alias ?setconnection='_setconnection'
function _setconnection {
	case "$#" in
	1) exec_sql "set connection $1"
	   _disp_connection		;;
	*) _show_connection
	   echo "?set[connection] CONNECT_NAME"		;;
	esac
}

alias ?dis='_disconnect'
alias ?disconnect='_disconnect'
function _disconnect {
	case "$#" in
	1) exec_sql "disconnect $1"	
	   _disp_connection		;;
	*) _show_connection		
	   echo "?dis[connect] {COONECT_NAME | ALL}"	;;
	esac
}

alias ?encoding='_set_client_encoding'
function _set_client_encoding {
	case "$#" in
	1) exec_sql "set client_encoding to '$1'"	
	   _disp_connection		;;
	*) _show_connection		;;
	esac
}

function _disp_connection {
	if [ $SQLCODE = 0 ]; then
		_show_connection
	fi
}

alias ?password='_change_password'
function _change_password {

	case "$#" in
	1) read -sp "Enter new password:" passwd1
	   echo ""
	   read -sp "Enter it again:" passwd2
	   echo ""
	   if [ $passwd1 != $passwd2 ]; then
		echo "Passwords didn't match."
		return;
	   fi
	   exec_sql "ALTER ROLE $1 with password '$passwd1';"	;;

	*) echo "?password USERNAME"	;;
	esac
}

#----------------------------------------------------
# 				Status
#----------------------------------------------------
alias ?dbc=_show_connection
alias ?dbconnection=_show_connection
alias ?opt='_show_exec_sql_option | more'
alias ?option='_show_exec_sql_option | more'
alias ?sta=_show_sqlcode
alias ?status=_show_sqlcode
alias ?ver=_show_version
alias ?version=_show_version

#----------------------------------------------------
# 				Pgbash help
#----------------------------------------------------
alias ??='_help_usage             | more'
alias ??sql='_help_sql_usage      | more'
alias ??connect='_help_connection | more'
alias ??sqlcode='_help_sqlcode    | more'
alias ??exec_sql='help exec_sql   | more'



#****************************************************
#	        List of Database Informations
#****************************************************

# ?u, ?du, ?dg

function _list_roles 
{ 		
	echo "[ List of roles ]"

	SELECT r.rolname AS "Role name",
		CASE WHEN r.rolsuper THEN 'yes' ELSE 'no' END AS "Superuser",
		CASE WHEN r.rolcreaterole THEN 'yes' ELSE 'no' END AS "Create role",
		CASE WHEN r.rolcreatedb THEN 'yes' ELSE 'no' END AS "Create DB",
		CASE WHEN r.rolconnlimit < 0 THEN CAST('no limit' AS pg_catalog.text)
			ELSE CAST(r.rolconnlimit AS pg_catalog.text)
		END AS "Connections",
			ARRAY(
				SELECT b.rolname 
				FROM pg_catalog.pg_auth_members m 
					JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid) 
				WHERE m.member = r.oid
			) as "Member of"
	FROM pg_catalog.pg_roles r
	ORDER BY 1;
	
    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any roles."
    fi
} 

# ?l

function _list_databases()
{
	echo "[ List of databases ]"

	if [ $# -lt 1 ]; then

	SELECT d.datname as "Name", r.rolname as "Owner",
		pg_catalog.pg_encoding_to_char(d.encoding) as "Encoding"
	FROM pg_catalog.pg_database d
		JOIN pg_catalog.pg_roles r ON d.datdba = r.oid
	ORDER BY 1;

	else

	SELECT d.datname as "Name", r.rolname as "Owner",
		pg_catalog.pg_encoding_to_char(d.encoding) as "Encoding",
		t.spcname as "Tablespace",
		pg_catalog.shobj_description(d.oid, 'pg_database') as "Description"
	FROM pg_catalog.pg_database d
		JOIN pg_catalog.pg_roles r ON d.datdba = r.oid
		JOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid
	ORDER BY 1;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any databases."
    fi
} 

# ?z, ?dp

function _list_privileges 
{
	echo "[ List of access privileges ]"

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind  WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'S' THEN 'sequence' 
		END as "Type",
		c.relacl as "Access privileges"
	FROM pg_catalog.pg_class c
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r', 'v', 'S') 
		AND n.nspname !~ '^pg_' AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1, 2;

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any privileges."
    fi
}  
function _list_permissions
{
	_list_privileges
}

# ?d

function _list_relations 
{ 
	echo "[ List of relations ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
			WHEN 'v' THEN 'view' 
			WHEN 'i' THEN 'index' 
			WHEN 'S' THEN 'sequence' 
			WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','v','S','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
			WHEN 'v' THEN 'view' 
			WHEN 'i' THEN 'index' 
			WHEN 'S' THEN 'sequence' 
			WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','v','S','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any relations."
	fi
}

# ?d NAME

function _list_relation  # $1 : table/index/sequence name
{  

	# Table info.
	SELECT c.oid, n.nspname, c.relname 
	INTO  :oid,  :nspname,  :relname
	FROM pg_catalog.pg_class c
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relname ~ '^($1)$'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 2, 3; 

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any relations."
		return;
	fi

	# General table info.
	SELECT relhasindex, relkind, relchecks, reltriggers, relhasrules, relhasoids , reltablespace
	INTO  :relhasindex,:relkind,:relchecks,:reltriggers,:relhasrules,:relhasoids ,:reltablespace
	FROM pg_catalog.pg_class 
	WHERE oid = '$oid';

	# Title
	case $relkind in
	'r') echo "[ Table \"$1\" ]";;
	'v') echo "[ View \"$1\" ]";;
	's') echo "[ Sequence \"$1\" ]";;
	'i') echo "[ Index \"$1\" ]";;
	'S') echo "[ Special relation \"$1\" ]";;
	't') echo "[ TOAST table \"$1\" ]";;
	'c') echo "[ Composite type \"$1\" ]";;
	*)   echo "[ Relation \"$1\" ]";;
	esac

	# Column Info.
	if [ $# -lt 2 ]; then

	SELECT 	a.attname as "Column", 
		pg_catalog.format_type(a.atttypid, a.atttypmod) as "Type",
		CASE WHEN a.attnotnull = 't' THEN 'not null' ELSE '' END AS "NotNull",
		(
		SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)
		FROM pg_catalog.pg_attrdef d
		WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef
		) as "Default"
	FROM pg_catalog.pg_attribute a
	WHERE a.attrelid = '$oid' AND a.attnum > 0 AND NOT a.attisdropped
	ORDER BY a.attnum;

	else

	SELECT 	a.attname as "Column", 
		pg_catalog.format_type(a.atttypid, a.atttypmod) as "Type",
		CASE WHEN a.attnotnull = 't' THEN 'not null' ELSE '' END AS "NotNull",
		(
		SELECT substring(pg_catalog.pg_get_expr(d.adbin, d.adrelid) for 128)
		FROM pg_catalog.pg_attrdef d
		WHERE d.adrelid = a.attrelid AND d.adnum = a.attnum AND a.atthasdef
		) as "Default",
		pg_catalog.col_description(a.attrelid, a.attnum) as "Description"
	FROM pg_catalog.pg_attribute a
	WHERE a.attrelid = '$oid' AND a.attnum > 0 AND NOT a.attisdropped
	ORDER BY a.attnum;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Check if table is a view
	if [ $relkind = "v" ]; then
		SELECT pg_catalog.pg_get_viewdef('$oid'::pg_catalog.oid, true)
		INTO  :viewdef;

		echo "View definition:"
		echo "$viewdef"
		echo ""

		### count rules other than the view rule:
		SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))
		FROM pg_catalog.pg_rewrite r
		WHERE r.ev_class = '$oid' AND r.rulename != '_RETURN' 
		ORDER BY 1;
	fi

	# Formatting
	T-
	B-
	S+ ":"

	# Indexes
	C+ "Indexes"

	SELECT c2.relname as "Name", 
		pg_catalog.pg_get_indexdef(i.indexrelid, 0, true) as "Index"
	FROM pg_catalog.pg_class c, pg_catalog.pg_class c2, pg_catalog.pg_index i 
	WHERE c.oid = '$oid' AND c.oid = i.indrelid AND i.indexrelid = c2.oid
	ORDER BY i.indisprimary DESC, i.indisunique DESC, c2.relname;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Check constraints:
	C+ "Check constraints"

	SELECT 	r.conname as "Name", 
			pg_catalog.pg_get_constraintdef(r.oid, true) as "Check"
	FROM pg_catalog.pg_constraint r
	WHERE r.conrelid = '$oid' AND r.contype = 'c' 
	ORDER BY 1;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Rules:
	C+ "Rules"

	SELECT r.rulename, trim(trailing ';' from pg_catalog.pg_get_ruledef(r.oid, true))
	FROM pg_catalog.pg_rewrite r
	WHERE r.ev_class = '$oid' 
	ORDER BY 1;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Triggers:
	C+ "Triggers"

	SELECT 	t.tgname as "Name", 
			pg_catalog.pg_get_triggerdef(t.oid) as "Trigger"
	FROM pg_catalog.pg_trigger t
	WHERE t.tgrelid = '$oid' AND (not tgisconstraint  OR 
		NOT EXISTS  (SELECT 1 FROM pg_catalog.pg_depend d    
		JOIN pg_catalog.pg_constraint c ON (d.refclassid = c.tableoid AND d.refobjid = c.oid)    
		WHERE d.classid = t.tableoid AND d.objid = t.oid AND d.deptype = 'i' AND c.contype = 'f'))   
	ORDER BY 1;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Foreign keys:
	C+ "Foreign keys"

	SELECT 	conname as "Name", 
			pg_catalog.pg_get_constraintdef(oid, true) as "Foreign key"
	FROM pg_catalog.pg_constraint r
	WHERE r.conrelid = '$oid' AND r.contype = 'f' 
	ORDER BY 1;

	if (($SQLCODE == 0 && $SQLNTUPLE > 0)); then
		echo ""
	fi

	# Inherits:
	C+ "Inherits"

	SELECT c.relname as "Inherits"
	FROM pg_catalog.pg_class c, pg_catalog.pg_inherits i 
	WHERE c.oid=i.inhparent AND i.inhrelid = '$oid' 
	ORDER BY inhseqno ASC;

	# Formatting
	C+
	T+
	B+
	S+ "|"
}

# ?dt

function _list_tables()
{
	echo "[ List of tables ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any tables."
    fi
}  

# ?di

function _list_indexes()
{
	echo "[ List of indexes ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		c2.relname as "Table"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid
		LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid
	WHERE c.relkind IN ('i','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		c2.relname as "Table",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid
		LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid
	WHERE c.relkind IN ('i','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any indexes."
    fi
}  

# ?dv

function _list_views()
{
	echo "[ List of views ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('v','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('v','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any views".
    fi
}

# ?ds

function _list_sequences()
{
	echo "[ List of sequences ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind  WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('S','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind  WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('S','')
		AND n.nspname NOT IN ('pg_catalog', 'pg_toast')
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any sequences."
    fi
}  

# ?dS

function _list_systables()
{
	echo "[ List of system tables ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','v','S','s','') 
		AND n.nspname = 'pg_catalog'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	else

	SELECT n.nspname as "Schema", c.relname as "Name",
		CASE c.relkind WHEN 'r' THEN 'table' 
						WHEN 'v' THEN 'view' 
						WHEN 'i' THEN 'index' 
						WHEN 'S' THEN 'sequence' 
						WHEN 's' THEN 'special' 
		END as "Type",
		r.rolname as "Owner",
		pg_catalog.obj_description(c.oid, 'pg_class') as "Description"
	FROM pg_catalog.pg_class c
		JOIN pg_catalog.pg_roles r ON r.oid = c.relowner
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
	WHERE c.relkind IN ('r','v','S','s','') 
		AND n.nspname = 'pg_catalog'
		AND pg_catalog.pg_table_is_visible(c.oid)
	ORDER BY 1,2;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any sequences."
    fi
}  

# ?da

function _list_aggregates 
{
	echo "[ List of aggregate functions ]"

	SELECT n.nspname as "Schema", p.proname AS "Name",
		CASE WHEN p.pronargs = 0 THEN CAST('*' AS pg_catalog.text)
			ELSE pg_catalog.array_to_string(
			ARRAY( 
				SELECT pg_catalog.format_type(p.proargtypes[s.i], NULL)
				FROM pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) 
					AS s(i)), ', '
			)
		END AS "Argument data types",
		pg_catalog.obj_description(p.oid, 'pg_proc') as "Description"
	FROM pg_catalog.pg_proc p
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
	WHERE p.proisagg
		AND pg_catalog.pg_function_is_visible(p.oid)
	ORDER BY 1, 2, 3; 

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any aggregate functions."
	fi
}

# ?db

function _list_tablespaces()
{
	echo "[ List of tablespaces ]"

	if [ $# -lt 1 ]; then

	SELECT spcname AS "Name",
		pg_catalog.pg_get_userbyid(spcowner) AS "Owner",
		spclocation AS "Location"
	FROM pg_catalog.pg_tablespace
	ORDER BY 1;

	else

	SELECT spcname AS "Name",
		pg_catalog.pg_get_userbyid(spcowner) AS "Owner",
		spclocation AS "Location",
		spcacl as "Access privileges"
	FROM pg_catalog.pg_tablespace
	ORDER BY 1;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any tablespaces."
	fi
}

# ?dc

function _list_conversions 
{
	echo "[ List of conversions ]"

	SELECT n.nspname AS "Schema",
		c.conname AS "Name",
		pg_catalog.pg_encoding_to_char(c.conforencoding) AS "Source",
		pg_catalog.pg_encoding_to_char(c.contoencoding) AS "Destination",
		CASE WHEN c.condefault THEN 'yes'
		ELSE 'no' END AS "Default?"
	FROM pg_catalog.pg_conversion c, pg_catalog.pg_namespace n
	WHERE n.oid = c.connamespace
		AND pg_catalog.pg_conversion_is_visible(c.oid)
	ORDER BY 1, 2;

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any conversions."
	fi
}

# ?dC

function _list_casts 
{
	echo "[ List of casts ]"

	SELECT pg_catalog.format_type(castsource, NULL) AS "Source type",
		pg_catalog.format_type(casttarget, NULL) AS "Target type",
		CASE WHEN castfunc = 0 THEN '(binary compatible)' ELSE p.proname
		END as "Function",
		CASE WHEN c.castcontext = 'e' THEN 'no'
			WHEN c.castcontext = 'a' THEN 'in assignment' ELSE 'yes'
		END as "Implicit?"
	FROM pg_catalog.pg_cast c LEFT JOIN pg_catalog.pg_proc p
		ON c.castfunc = p.oid
	ORDER BY 1, 2;

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any casts."
	fi
}

# ?dd

function _list_comment 
{
	echo "[ List of comment ]"

	SELECT DISTINCT tt.nspname AS "Schema", tt.name AS "Name", 
		tt.object AS "Object", d.description AS "Description"
	FROM (
		SELECT p.oid as oid, p.tableoid as tableoid,
			n.nspname as nspname,
			CAST(p.proname AS pg_catalog.text) as name,  
			CAST('aggregate' AS pg_catalog.text) as object
		FROM pg_catalog.pg_proc p
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
		WHERE p.proisagg AND pg_catalog.pg_function_is_visible(p.oid)
		UNION ALL
		SELECT p.oid as oid, p.tableoid as tableoid, n.nspname as nspname,
			CAST(p.proname AS pg_catalog.text) as name,  
			CAST('function' AS pg_catalog.text) as object
		FROM pg_catalog.pg_proc p
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
		WHERE p.prorettype <> 'pg_catalog.cstring'::pg_catalog.regtype
			AND (p.proargtypes[0] IS NULL
			OR   p.proargtypes[0] <> 'pg_catalog.cstring'::pg_catalog.regtype)
			AND NOT p.proisagg AND pg_catalog.pg_function_is_visible(p.oid)
		UNION ALL
		SELECT o.oid as oid, o.tableoid as tableoid, n.nspname as nspname,
			CAST(o.oprname AS pg_catalog.text) as name,  
			CAST('operator' AS pg_catalog.text) as object
		FROM pg_catalog.pg_operator o
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = o.oprnamespace
		WHERE pg_catalog.pg_operator_is_visible(o.oid)
		UNION ALL
		SELECT t.oid as oid, t.tableoid as tableoid, n.nspname as nspname,
			pg_catalog.format_type(t.oid, NULL) as name,  
			CAST('data type' AS pg_catalog.text) as object
		FROM pg_catalog.pg_type t
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
		WHERE pg_catalog.pg_type_is_visible(t.oid)
		UNION ALL
		SELECT c.oid as oid, c.tableoid as tableoid, n.nspname as nspname,
			CAST(c.relname AS pg_catalog.text) as name,
			CAST(
				CASE c.relkind 	WHEN 'r' THEN 'table' 
								WHEN 'v' THEN 'view' 
								WHEN 'i' THEN 'index' 
								WHEN 'S' THEN 'sequence' 
				END  AS pg_catalog.text
			) as object
		FROM pg_catalog.pg_class c
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		WHERE c.relkind IN ('r', 'v', 'i', 'S') AND pg_catalog.pg_table_is_visible(c.oid)
		UNION ALL
		SELECT r.oid as oid, r.tableoid as tableoid, n.nspname as nspname,
			CAST(r.rulename AS pg_catalog.text) as name,  
			CAST('rule' AS pg_catalog.text) as object
		FROM pg_catalog.pg_rewrite r
			JOIN pg_catalog.pg_class c ON c.oid = r.ev_class
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		WHERE r.rulename != '_RETURN' AND pg_catalog.pg_table_is_visible(c.oid)
		UNION ALL
		SELECT t.oid as oid, t.tableoid as tableoid, n.nspname as nspname,
			CAST(t.tgname AS pg_catalog.text) as name,  
			CAST('trigger' AS pg_catalog.text) as object
		FROM pg_catalog.pg_trigger t
			JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid
			LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
		WHERE pg_catalog.pg_table_is_visible(c.oid)
	) AS tt
		JOIN pg_catalog.pg_description d 
			ON (tt.oid = d.objoid AND tt.tableoid = d.classoid AND d.objsubid = 0)
	ORDER BY 1, 2, 3;

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any comments."
	fi
}

# ?dD

function _list_domains 
{
	echo "[ List of domains ]"

	SELECT n.nspname as "Schema",
		t.typname as "Name",
		pg_catalog.format_type(t.typbasetype, t.typtypmod) as "Type",
		CASE WHEN t.typnotnull AND t.typdefault IS NOT NULL THEN 'not null default '||t.typdefault
			WHEN t.typnotnull AND t.typdefault IS NULL THEN 'not null'
			WHEN NOT t.typnotnull AND t.typdefault IS NOT NULL THEN 'default '||t.typdefault
			ELSE ''
		END as "Modifier",
		pg_catalog.pg_get_constraintdef(r.oid, true) as "Check"
	FROM pg_catalog.pg_type t
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
		LEFT JOIN pg_catalog.pg_constraint r ON t.oid = r.contypid
	WHERE t.typtype = 'd' AND pg_catalog.pg_type_is_visible(t.oid)
	ORDER BY 1, 2;

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any domains."
    fi
}

# ?df

function _list_functions()
{
	echo "[ List of functions ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema",
		p.proname as "Name",
		CASE WHEN p.proretset THEN 'setof ' ELSE '' END ||
		pg_catalog.format_type(p.prorettype, NULL) as "Result data type",
		CASE WHEN proallargtypes IS NOT NULL THEN
			pg_catalog.array_to_string(ARRAY(
			SELECT
				CASE
				WHEN p.proargmodes[s.i] = 'i' THEN ''
				WHEN p.proargmodes[s.i] = 'o' THEN 'OUT '
				WHEN p.proargmodes[s.i] = 'b' THEN 'INOUT '
				END ||
				CASE
				WHEN COALESCE(p.proargnames[s.i], '') = '' THEN ''
					ELSE p.proargnames[s.i] || ' '
				END ||
				pg_catalog.format_type(p.proallargtypes[s.i], NULL)
			FROM
				pg_catalog.generate_series(1, pg_catalog.array_upper(p.proallargtypes, 1)) AS s(i)
				), ', '
			)
		ELSE 
			pg_catalog.array_to_string(ARRAY(
			SELECT
				CASE
				WHEN COALESCE(p.proargnames[s.i+1], '') = '' THEN ''
				ELSE p.proargnames[s.i+1] || ' '
				END ||
				pg_catalog.format_type(p.proargtypes[s.i], NULL)
			FROM
				pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)
				), ', '
			)
		END AS "Argument data types"
	FROM pg_catalog.pg_proc p
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
	WHERE p.prorettype <> 'pg_catalog.cstring'::pg_catalog.regtype
		AND (p.proargtypes[0] IS NULL
		OR   p.proargtypes[0] <> 'pg_catalog.cstring'::pg_catalog.regtype)
		AND NOT p.proisagg
		AND pg_catalog.pg_function_is_visible(p.oid)
	ORDER BY 1, 2, 3, 4;

	else

	SELECT n.nspname as "Schema",
		p.proname as "Name",
		CASE WHEN p.proretset THEN 'setof ' ELSE '' END ||
		pg_catalog.format_type(p.prorettype, NULL) as "Result data type",
		CASE WHEN proallargtypes IS NOT NULL THEN
			pg_catalog.array_to_string(ARRAY(
			SELECT
				CASE
				WHEN p.proargmodes[s.i] = 'i' THEN ''
				WHEN p.proargmodes[s.i] = 'o' THEN 'OUT '
				WHEN p.proargmodes[s.i] = 'b' THEN 'INOUT '
				END ||
				CASE
				WHEN COALESCE(p.proargnames[s.i], '') = '' THEN ''
					ELSE p.proargnames[s.i] || ' '
				END ||
				pg_catalog.format_type(p.proallargtypes[s.i], NULL)
			FROM
				pg_catalog.generate_series(1, pg_catalog.array_upper(p.proallargtypes, 1)) AS s(i)
				), ', '
			)
		ELSE 
			pg_catalog.array_to_string(ARRAY(
			SELECT
				CASE
				WHEN COALESCE(p.proargnames[s.i+1], '') = '' THEN ''
				ELSE p.proargnames[s.i+1] || ' '
				END ||
				pg_catalog.format_type(p.proargtypes[s.i], NULL)
			FROM
				pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)
				), ', '
			)
		END AS "Argument data types",
		r.rolname as "Owner",
		l.lanname as "Language",
		p.prosrc as "Source code",
		pg_catalog.obj_description(p.oid, 'pg_proc') as "Description"
	FROM pg_catalog.pg_proc p
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
		LEFT JOIN pg_catalog.pg_language l ON l.oid = p.prolang
		JOIN pg_catalog.pg_roles r ON r.oid = p.proowner
	WHERE p.prorettype <> 'pg_catalog.cstring'::pg_catalog.regtype
		AND (p.proargtypes[0] IS NULL
		OR   p.proargtypes[0] <> 'pg_catalog.cstring'::pg_catalog.regtype)
		AND NOT p.proisagg
		AND pg_catalog.pg_function_is_visible(p.oid)
	ORDER BY 1, 2, 3, 4;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any functions."
	fi
}  

# ?dn

function _list_schemas()
{
	echo "[ List of schemas ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname AS "Name", r.rolname AS "Owner"
	FROM pg_catalog.pg_namespace n JOIN pg_catalog.pg_roles r ON n.nspowner=r.oid
	WHERE   (n.nspname !~ '^pg_temp_' OR
		n.nspname = (pg_catalog.current_schemas(true))[1])
	ORDER BY 1;

	else

	SELECT n.nspname AS "Name", r.rolname AS "Owner",
			n.nspacl as "Access privileges",  
			pg_catalog.obj_description(n.oid, 'pg_namespace') as "Description"
	FROM pg_catalog.pg_namespace n JOIN pg_catalog.pg_roles r ON n.nspowner=r.oid
	WHERE   (n.nspname !~ '^pg_temp_' OR
			n.nspname = (pg_catalog.current_schemas(true))[1])
	ORDER BY 1;

	fi

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any schames."
    fi
}

# ?do

function _list_operators 
{
	echo "[ List of operators ]"

	SELECT n.nspname as "Schema",
		o.oprname AS "Name",
		CASE WHEN o.oprkind='l' THEN NULL ELSE pg_catalog.format_type(o.oprleft, NULL) 
		END AS "Left arg type",
		CASE WHEN o.oprkind='r' THEN NULL ELSE pg_catalog.format_type(o.oprright, NULL) 
		END AS "Right arg type",
		pg_catalog.format_type(o.oprresult, NULL) AS "Result type",
		coalesce(pg_catalog.obj_description(o.oid, 'pg_operator'),
		pg_catalog.obj_description(o.oprcode, 'pg_proc')) AS "Description"
	FROM pg_catalog.pg_operator o
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = o.oprnamespace
	WHERE pg_catalog.pg_operator_is_visible(o.oid)
	ORDER BY 1, 2, 3, 4;

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any operations."
    fi
}  

# ?dl, ?lo_list

function _lo_list 
{
	echo "[ List of large objects ]"

	SELECT 	loid as "ID",
			pg_catalog.obj_description(loid, 'pg_largeobject') as "Description"
	FROM (SELECT DISTINCT loid FROM pg_catalog.pg_largeobject) x
	ORDER BY 1;

    if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any large objects."
    fi
}

# ?dT

function _list_types()
{
	echo "[ List of data types ]"

	if [ $# -lt 1 ]; then

	SELECT n.nspname as "Schema",
		pg_catalog.format_type(t.oid, NULL) AS "Name",
		pg_catalog.obj_description(t.oid, 'pg_type') as "Description"
	FROM pg_catalog.pg_type t
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	WHERE (t.typrelid = 0 OR 
		(SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) 
		AND t.typname !~ '^_' AND pg_catalog.pg_type_is_visible(t.oid)
	ORDER BY 1, 2;

	else

	SELECT n.nspname as "Schema",
		pg_catalog.format_type(t.oid, NULL) AS "Name",
		t.typname AS "Internal name",
		CASE WHEN t.typrelid != 0 THEN CAST('tuple' AS pg_catalog.text)
			WHEN t.typlen < 0 THEN CAST('var' AS pg_catalog.text)
			ELSE CAST(t.typlen AS pg_catalog.text)
		END AS "Size",
		pg_catalog.obj_description(t.oid, 'pg_type') as "Description"
	FROM pg_catalog.pg_type t
		LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
	WHERE (t.typrelid = 0 OR 
		(SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) 
		AND t.typname !~ '^_' AND pg_catalog.pg_type_is_visible(t.oid)
	ORDER BY 1, 2;

	fi

	if (($SQLCODE == 0 && $SQLNTUPLE == 0)); then
		echo "# Did not find any data types."
	fi
}  


#****************************************************
#	                  Status 
#****************************************************

# ?dbc, ?dbconnection

function _show_connection 
{
	exec_sql -Lm 
} 

# ?opt, ?option

function _show_exec_sql_option 
{
	echo "# EXEC_SQL_OPTION"
	echo "  Usage:"
	echo "  set EXEC_SQL_OPTION DEFAULT ;   --- reset DEFAULT"
	echo "  set EXEC_SQL_OPTION CGI ;       --- set CGI mode"
	echo "  set <option_name>[=value] ;"
	echo " "
	echo "  ex)"
	echo "  SET OPTION_ECHO; or SET OPTION_ECHO=ON; or SET OPTION_ECHO=TRUE;"
	echo "  SET OPTION_BOTTOM=OFF; or SET OPTION_BOTTOM=FALSE;"
	echo "  set OPTION_SEPARATOR=',';"
	echo "  set OPTION_NULLSTRING=\"\\N\";"
	echo " "
	echo "+-------------------+-------------------------+-------+---------------"
	echo "|   <option_name>   |      Comment            |DEFAULT| Current Value "
	echo "+-------------------+-------------------------+-------+---------------"
	echo "| OPTION_ECHO       | turn on/off ECHO query  | OFF   | $OPTION_ECHO"
	echo "| OPTION_QUIET      | turn on/off QUIET mode  | OFF   | $OPTION_QUIET"
	echo "| OPTION_HEADER     | turn on/off TOP_header  | ON    | $OPTION_HEADER"
	echo "| OPTION_BOTTOM     | turn on/off BOTTOM_print| ON    | $OPTION_BOTTOM"
	echo "| OPTION_ALIGNMENT  | turn on/off ALIGNMENT   | ON    | $OPTION_ALIGNMENT"
	echo "| OPTION_FRAME      | turn on/off OUTER_FRAME | OFF   | $OPTION_FRAME"
	echo "| OPTION_EXPANDED   | turn on/off EXPANDED    | OFF   | $OPTION_EXPANDED"
	echo "| OPTION_SEPARATOR  | set SEPARATOR character | ''    | '$OPTION_SEPARATOR'"
	echo "| OPTION_NULLSTRING | set NULL string         | \"\"    | \"$OPTION_NULLSTRING\" "
	echo "| OPTION_ZEROSTRING | set ZERO string         | \"\"    | \"$OPTION_ZEROSTRING\" "
	echo "| OPTION_CAPTION    | set CAPTION             | \"\"    | \"$OPTION_CAPTION\" "
	echo "+-------------------+-------------------------+-------+---------------"
	echo ""
	echo "[ CGI_mode / HTML_output_mode ]"
	echo "+-------------------+-------------------------+-------+---------------"
	echo "|   <option_name>   |      Comment            |DEFAULT| Current Value "
	echo "+-------------------+-------------------------+-------+---------------"
	echo "| OPTION_HTML       | turn on/off HTML mode   | OFF   | $OPTION_HTML"
	echo "| OPTION_TABLETAG   | set HTML table tag      | \"\"    | \"$OPTION_TABLETAG\" "
	echo "| OPTION_HEADERTR   | set HTML header <TR>    | \"\"    | \"$OPTION_HEADERTR\" "
	echo "| OPTION_HEADERTH   | set HTML header <TH>    | \"\"    | \"$OPTION_HEADERTH\" "
	echo "| OPTION_BODYTAG    | set HTML body <TD> tag  | \"\"    | \"$OPTION_BODYTAG\" "
	echo "| OPTION_INPUTTAG   | turn on/off INPUT tag   | OFF   | $OPTION_INPUTTAG"
	echo "| OPTION_INPUTSIZE  | set HTML input tag SIZE | \"\"    | \"$OPTION_INPUTSIZE\""
	echo "+-------------------+-------------------------+-------+---------------"
}

# ?sta, ?status

function _show_sqlcode  # status after SQL execution
{
	exec_sql -s
}

# ?ver, ?version

function _show_version 
{
	OPTION_WORK=$OPTION_QUIET
	set OPTION_QUIET;
	select version() into :version;
	set OPTION_QUIET=$OPTION_WORK;

	echo "# $version"
	exec_sql -v
	echo "# Pgbashrc Version $PGBASHRC_VERSION"
} 

#****************************************************
#	                    Help 
#****************************************************

# ??

function _help_usage 
{
	echo "# Usage:"
	echo "  Type '?'  for help with pgbash commands."
	echo "  Type 'exit' or 'Ctrl+D' to terminate Pgbash."
	echo ""
}

# ??sql

function _help_sql_usage
{
	echo "# SQL usage:"
	echo "  Type '[timespec] SQL; [pipeline][redirection][&]'"
	echo "  ex)"
	echo "  select * from test limit 300;"
	echo "  select * from test; > /tmp/test.dat"
	echo "  select * from test; >> /tmp/test.dat &"
	echo "  select * from test; | more"
	echo "  time  select * from test limit 300;"
	echo " "
	echo "  select code, name into :code, :name from test;"
	echo "  if [ \$code = '101' ]; then"
	echo "      echo \"code=\$code name=\$name\""
	echo "  fi"
	echo " "
	echo "  begin;"
	echo "  declare cur cursor for select code,name from test order by code;"
	echo "  while (( \$SQLCODE == \$SQL_OK )); do"
	echo "     fetch in cur into :code, :name;"
	echo "     if (( \$SQLCODE < 0 || \$SQLCODE == \$SQL_NOT_FOUND)); then"
	echo "        break"
	echo "     else"
	echo "         echo \"code=\$code  name=\$name\"  "
	echo "     fi"
	echo "  done"
	echo "  end;"
}

# ??connect

function _help_connection
{
	echo "# Connection:"
	echo ""
	echo "  1. Connect to database."
	echo "     Type 'connect to DB[@SERVERNAME][:PORT] [as CONNECT_NAME] [user UID [PASSWD|NULL]];'"
	echo "          ,or"
	echo "          '?con[nect] DB[@SERVERNAME][:PORT]    [CONNECT_NAME       [UID [PASSWD|NULL]]]'"
	echo "           or"
	echo "          'connect to DEFAULT;'"
	echo "     ex)"
	echo "     connect to DEFAULT; <-- DB user is LoginID, Password is NULL"
	echo "     connect to db1;"
	echo "     connect to testdb:5433         as db2;"
	echo "     connect to db3@SERVERNAME      as db3 user user1 xxxxxx;"
	echo "     connect to db4@SERVERNAME:5434 as db4 user user1 xxxxxx;"
	echo " "
	echo "  2. Set connection, if some databases are connected. "
	echo "     Type 'set connection   CONNECT_NAME;'"
	echo "          ,or"
	echo "          '?set[connection] CONNECT_NAME'"
	echo "          ,or"
	echo "          The last connection is used, if 'set connection' has not been done."
	echo "     ex)"
	echo "     connect to db1;"
	echo "     connect to db2;"
	echo "     set connection db1;"
	echo "     select * from test;"
	echo " "
	echo "  3. Execute SQL."
	echo "     'connect to DEFAULT;' is automatically done before executing SQL,"
	echo "     if database connection has not been done."
	echo " "
	echo "  4. Disconnect database."
	echo "     Type 'disconnect    {CONNECT_NAME | ALL};'"
	echo "          ,or"
	echo "          '?dis[connect] {CONNECT_NAME | ALL}'"
	echo "          ,or"
	echo "     Connections are automatically closed when Pgbash is terminated."
	echo "     ex)"
	echo "     disconnect db1;"
	echo "     disconnect all;"
	echo " "
}

# ??sqlcode

function _help_sqlcode 
{
	echo "# SQLCODE"
	echo "  ex)"
	echo "  begin;"
	echo "  declare cur cursor for select code,name from test order by code;"
	echo "  while (( \$SQLCODE == \$SQL_OK )); do"
	echo "     fetch in cur into :code, :name;"
	echo "     if (( \$SQLCODE < 0 || \$SQLCODE == \$SQL_NOT_FOUND)); then"
	echo "        break"
	echo "     else"
	echo "         echo \"code=\$code  name=\$name\"  "
	echo "     fi"
	echo "  done"
	echo "  end;"
	echo ""
	echo "-------------------------+-------------------------------------------+--------"
	echo "       Value Name        |               Comment                     | Value"
	echo "-------------------------+-------------------------------------------+--------"
	echo " \$SQL_OK                 | normal end.                               |$SQL_OK"
	echo " \$SQL_NOT_FOUND          | EOF(End Of File).                         |$SQL_NOT_FOUND"
	echo " \$SQL_OUT_OF_MEMORY      | out of memory.                            |$SQL_OUT_OF_MEMORY"
	echo " \$SQL_SYSTEM_ERROR       | system error.                             |$SQL_SYSTEM_ERROR"
	echo " \$SQL_TOO_MANY_ARGUMENTS | too many arguments in fetch_stmt.         |$SQL_TOO_MANY_ARGUMENTS"
	echo " \$SQL_TOO_FEW_ARGUMENTS  | too few  arguments in fetch_stmt.         |$SQL_TOO_FEW_ARGUMENTS"
	echo " \$SQL_CONNECT_ERROR      | database connection error.                |$SQL_CONNECT_ERROR"   
	echo " \$SQL_INT_FORMAT         | int format error.                         |$SQL_INT_FORMAT"
	echo " \$SQL_UINT_FORMAT        | uint format error.                        |$SQL_UINT_FORMAT"
	echo " \$SQL_FLOAT_FORMAT       | float format error.                       |$SQL_FLOAT_FORMAT"
	echo " \$SQL_NUMERIC_FORMAT     | numeric format error.                     |$SQL_NUMERIC_FORMAT"
	echo " \$SQL_INTERVAL_FORMAT    | interval format error.                    |$SQL_INTERVAL_FORMAT"
	echo " \$SQL_DATE_FORMAT        | date format error.                        |$SQL_DATE_FORMAT"
	echo " \$SQL_TIMESTAMP_FORMAT   | timestamp format error.                   |$SQL_TIMESTAMP_FORMAT"
	echo " \$SQL_CONVERT_BOOL       | convert bool error.                       |$SQL_CONVERT_BOOL"
	echo " \$SQL_EMPTY              | empty.                                    |$SQL_EMPTY"
	echo " \$SQL_MISSING_INDICATOR  | missing_indicator.                        |$SQL_MISSING_INDICATOR"
	echo " \$SQL_NO_ARRAY           | no array.                                 |$SQL_NO_ARRAY"
	echo " \$SQL_DATA_NOT_ARRAY     | data not array.                           |$SQL_DATA_NOT_ARRAY"
	echo " \$SQL_ARRAY_INSERT       | array insert error.                       |$SQL_ARRAY_INSERT"
	echo " \$SQL_NO_CONN            | no connection.                            |$SQL_NO_CONN"
	echo " \$SQL_NOT_CONN           |can not connection.                        |$SQL_NOT_CONN"
	echo " \$SQL_INVALID_STMT       | invalid statements.                       |$SQL_INVALID_STMT" 
	echo " \$SQL_READONLY_SHELLVAR  | can not set read-only shell variable.     |$SQL_READONLY_SHELLVAR"
	echo " \$SQL_DB_NOT_OPEN        | database not open.                        |$SQL_DB_NOT_OPEN"
	echo " \$SQL_CNAME_NOT_FOUND    | connect-name not found.                   |$SQL_CNAME_NOT_FOUND"
	echo " \$SQL_CNAME_ALREADY_USE  | connect-name already exist.               |$SQL_CNAME_ALREADY_USE"
	echo " \$SQL_INVALID_COMMAND    | invalid command.                          |$SQL_INVALID_COMMAND"
	echo " \$SQL_INVALID_DATA       | invalid data.                             |$SQL_INVALID_DATA"

	echo " \$SQL_UNKNOWN_DESCRIPTOR | unknown descriptor.                       |$SQL_UNKNOWN_DESCRIPTOR"
	echo " \$SQL_INVALID_DESC_INDEX | invalid descriptor index.                 |$SQL_INVALID_DESC_INDEX"
	echo " \$SQL_UNKNOWN_DESC_ITEM  | unknown descriptor item.                  |$SQL_UNKNOWN_DESC_ITEM"
	echo " \$SQL_VAR_NOT_NUMERIC    | variable not numeric.                     |$SQL_VAR_NOT_NUMERIC"
	echo " \$SQL_VAR_NOT_CHAR       | variable not charater.                    |$SQL_VAR_NOT_CHAR"

	echo " \$SQL_BAD_RESPONSE       | bad response(backend maybe died).         |$SQL_BAD_RESPONSE"
	echo " \$SQL_EMPTY_QUERY        | empty query (backend lost query).         |$SQL_EMPTY_QUERY"
	echo " \$SQL_CONNECTION_BAD     | connection bad(disconnect backend)        |$SQL_FATAL_ERROR"
	echo " \$SQL_FATAL_ERROR        | query fatal error   (SQL error on backend)|$SQL_FATAL_ERROR"
	echo " \$SQL_NONFATAL_ERROR     | query nonfatal error(SQL error on backend)|$SQL_NONFATAL_ERROR"
	echo " \$SQL_NULL               | indicator is NULL.                        |$SQL_NULL"
	echo "-------------------------+-------------------------------------------+--------"
}

# ??h, ??h SQL

function	_help_sql
{
	case "$*" in

	"abort" | "ABORT" )
	echo "Command:     ABORT"
	echo "Description: abort the current transaction"
	echo "Syntax:"
	echo "ABORT [ WORK | TRANSACTION ]"
	;;

	"alter aggregate" | "ALTER AGGREGATE" )
	echo "Command:     ALTER AGGREGATE"
	echo "Description: change the definition of an aggregate function"
	echo "Syntax:"
	echo "ALTER AGGREGATE name ( type ) RENAME TO new_name"
	echo "ALTER AGGREGATE name ( type ) OWNER TO new_owner"
	echo "ALTER AGGREGATE name ( type ) SET SCHEMA new_schema"
	;;

	"alter conversion" | "ALTER CONVERSION" )
	echo "Command:     ALTER CONVERSION"
	echo "Description: change the definition of a conversion"
	echo "Syntax:"
	echo "ALTER CONVERSION name RENAME TO newname"
	echo "ALTER CONVERSION name OWNER TO newowner"
	;;

	"alter database" | "ALTER DATABASE" )
	echo "Command:     ALTER DATABASE"
	echo "Description: change a database"
	echo "Syntax:"
	echo "ALTER DATABASE name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo ""
	echo "    CONNECTION LIMIT connlimit"
	echo ""
	echo "ALTER DATABASE name SET parameter { TO | = } { value | DEFAULT }"
	echo "ALTER DATABASE name RESET parameter"
	echo ""
	echo "ALTER DATABASE name RENAME TO newname"
	echo ""
	echo "ALTER DATABASE name OWNER TO new_owner"
	;;

	"alter domain" | "ALTER DOMAIN" )
	echo "Command:     ALTER DOMAIN"
	echo "Description: change the definition of a domain"
	echo "Syntax:"
	echo "ALTER DOMAIN name"
	echo "    { SET DEFAULT expression | DROP DEFAULT }"
	echo "ALTER DOMAIN name"
	echo "    { SET | DROP } NOT NULL"
	echo "ALTER DOMAIN name"
	echo "    ADD domain_constraint"
	echo "ALTER DOMAIN name"
	echo "    DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]"
	echo "ALTER DOMAIN name"
	echo "    OWNER TO new_owner "
	echo "ALTER DOMAIN name"
	echo "    SET SCHEMA new_schema"
	;;

	"alter function" | "ALTER FUNCTION" )
	echo "Command:     ALTER FUNCTION"
	echo "Description: change the definition of a function"
	echo "Syntax:"
	echo "ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    action [, ... ] [ RESTRICT ]"
	echo "ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    RENAME TO new_name"
	echo "ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    OWNER TO new_owner"
	echo "ALTER FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    SET SCHEMA new_schema"
	echo ""
	echo "where action is one of:"
	echo ""
	echo "    CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT"
	echo "    IMMUTABLE | STABLE | VOLATILE"
	echo "    [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER"
	;;

	"alter group" | "ALTER GROUP" )
	echo "Command:     ALTER GROUP"
	echo "Description: change role name or membership"
	echo "Syntax:"
	echo "ALTER GROUP groupname ADD USER username [, ... ]"
	echo "ALTER GROUP groupname DROP USER username [, ... ]"
	echo ""
	echo "ALTER GROUP groupname RENAME TO newname"
	;;

	"alter index" | "ALTER INDEX" )
	echo "Command:     ALTER INDEX"
	echo "Description: change the definition of an index"
	echo "Syntax:"
	echo "ALTER INDEX name RENAME TO new_name"
	echo "ALTER INDEX name SET TABLESPACE tablespace_name"
	;;

	"alter language" | "ALTER LANGUAGE" )
	echo "Command:     ALTER LANGUAGE"
	echo "Description: change the definition of a procedural language"
	echo "Syntax:"
	echo "ALTER LANGUAGE name RENAME TO newname"
	;;

	"alter operator class" | "ALTER OPERATOR CLASS" )
	echo "Command:     ALTER OPERATOR CLASS"
	echo "Description: change the definition of an operator class"
	echo "Syntax:"
	echo "ALTER OPERATOR CLASS name USING index_method RENAME TO newname"
	echo "ALTER OPERATOR CLASS name USING index_method OWNER TO newowner"
	;;

	"alter operator" | "ALTER OPERATOR" )
	echo "Command:     ALTER OPERATOR"
	echo "Description: change the definition of an operator"
	echo "Syntax:"
	echo "ALTER OPERATOR name ( { lefttype | NONE } , { righttype | NONE } ) OWNER TO newowner"
	;;

	"alter role" | "ALTER ROLE" )
	echo "Command:     ALTER ROLE"
	echo "Description: change a database role"
	echo "Syntax:"
	echo "ALTER ROLE name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | CONNECTION LIMIT connlimit"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo ""
	echo "ALTER ROLE name RENAME TO newname"
	echo ""
	echo "ALTER ROLE name SET parameter { TO | = } { value | DEFAULT }"
	echo "ALTER ROLE name RESET parameter"
	;;

	"alter schema" | "ALTER SCHEMA" )
	echo "Command:     ALTER SCHEMA"
	echo "Description: change the definition of a schema"
	echo "Syntax:"
	echo "ALTER SCHEMA name RENAME TO newname"
	echo "ALTER SCHEMA name OWNER TO newowner"
	;;

	"alter sequence" | "ALTER SEQUENCE" )
	echo "Command:     ALTER SEQUENCE"
	echo "Description: change the definition of a sequence generator"
	echo "Syntax:"
	echo "ALTER SEQUENCE name [ INCREMENT [ BY ] increment ]"
	echo "    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]"
	echo "    [ RESTART [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]"
	echo "ALTER SEQUENCE name SET SCHEMA new_schema"
	;;

	"alter table" | "ALTER TABLE" )
	echo "Command:     ALTER TABLE"
	echo "Description: change the definition of a table"
	echo "Syntax:"
	echo "ALTER TABLE [ ONLY ] name [ * ]"
	echo "    action [, ... ]"
	echo "ALTER TABLE [ ONLY ] name [ * ]"
	echo "    RENAME [ COLUMN ] column TO new_column"
	echo "ALTER TABLE name"
	echo "    RENAME TO new_name"
	echo "ALTER TABLE name"
	echo "    SET SCHEMA new_schema"
	echo ""
	echo "where action is one of:"
	echo ""
	echo "    ADD [ COLUMN ] column type [ column_constraint [ ... ] ]"
	echo "    DROP [ COLUMN ] column [ RESTRICT | CASCADE ]"
	echo "    ALTER [ COLUMN ] column TYPE type [ USING expression ]"
	echo "    ALTER [ COLUMN ] column SET DEFAULT expression"
	echo "    ALTER [ COLUMN ] column DROP DEFAULT"
	echo "    ALTER [ COLUMN ] column { SET | DROP } NOT NULL"
	echo "    ALTER [ COLUMN ] column SET STATISTICS integer"
	echo "    ALTER [ COLUMN ] column SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }"
	echo "    ADD table_constraint"
	echo "    DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]"
	echo "    DISABLE TRIGGER [ trigger_name | ALL | USER ]"
	echo "    ENABLE TRIGGER [ trigger_name | ALL | USER ]"
	echo "    CLUSTER ON index_name"
	echo "    SET WITHOUT CLUSTER"
	echo "    SET WITHOUT OIDS"
	echo "    OWNER TO new_owner"
	echo "    SET TABLESPACE new_tablespace"
	;;

	"alter tablespace" | "ALTER TABLESPACE" )
	echo "Command:     ALTER TABLESPACE"
	echo "Description: change the definition of a tablespace"
	echo "Syntax:"
	echo "ALTER TABLESPACE name RENAME TO newname"
	echo "ALTER TABLESPACE name OWNER TO newowner"
	;;

	"alter trigger" | "ALTER TRIGGER" )
	echo "Command:     ALTER TRIGGER"
	echo "Description: change the definition of a trigger"
	echo "Syntax:"
	echo "ALTER TRIGGER name ON table RENAME TO newname"
	;;

	"alter type" | "ALTER TYPE" )
	echo "Command:     ALTER TYPE"
	echo "Description: change the definition of a type"
	echo "Syntax:"
	echo "ALTER TYPE name OWNER TO new_owner "
	echo "ALTER TYPE name SET SCHEMA new_schema"
	;;

	"alter user" | "ALTER USER" )
	echo "Command:     ALTER USER"
	echo "Description: change a database role"
	echo "Syntax:"
	echo "ALTER USER name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | CONNECTION LIMIT connlimit"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo ""
	echo "ALTER USER name RENAME TO newname"
	echo ""
	echo "ALTER USER name SET parameter { TO | = } { value | DEFAULT }"
	echo "ALTER USER name RESET parameter"
	;;

	"analyze" | "ANALYZE" )
	echo "Command:     ANALYZE"
	echo "Description: collect statistics about a database"
	echo "Syntax:"
	echo "ANALYZE [ VERBOSE ] [ table [ (column [, ...] ) ] ]"
	;;

	"begin" | "BEGIN" )
	echo "Command:     BEGIN"
	echo "Description: start a transaction block"
	echo "Syntax:"
	echo "BEGIN [ WORK | TRANSACTION ] [ transaction_mode [, ...] ]"
	echo ""
	echo "where transaction_mode is one of:"
	echo ""
	echo "    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }"
	echo "    READ WRITE | READ ONLY"
	;;

	"checkpoint" | "CHECKPOINT" )
	echo "Command:     CHECKPOINT"
	echo "Description: force a transaction log checkpoint"
	echo "Syntax:"
	echo "CHECKPOINT"
	;;

	"close" | "CLOSE" )
	echo "Command:     CLOSE"
	echo "Description: close a cursor"
	echo "Syntax:"
	echo "CLOSE name"
	;;

	"cluster" | "CLUSTER" )
	echo "Command:     CLUSTER"
	echo "Description: cluster a table according to an index"
	echo "Syntax:"
	echo "CLUSTER indexname ON tablename"
	echo "CLUSTER tablename"
	echo "CLUSTER"
	;;

	"comment" | "COMMENT" )
	echo "Command:     COMMENT"
	echo "Description: define or change the comment of an object"
	echo "Syntax:"
	echo "COMMENT ON"
	echo "{"
	echo "  TABLE object_name |"
	echo "  COLUMN table_name.column_name |"
	echo "  AGGREGATE agg_name (agg_type) |"
	echo "  CAST (sourcetype AS targettype) |"
	echo "  CONSTRAINT constraint_name ON table_name |"
	echo "  CONVERSION object_name |"
	echo "  DATABASE object_name |"
	echo "  DOMAIN object_name |"
	echo "  FUNCTION func_name ( [ [ argmode ] [ argname ] argtype [, ...] ] ) |"
	echo "  INDEX object_name |"
	echo "  LARGE OBJECT large_object_oid |"
	echo "  OPERATOR op (leftoperand_type, rightoperand_type) |"
	echo "  OPERATOR CLASS object_name USING index_method |"
	echo "  [ PROCEDURAL ] LANGUAGE object_name |"
	echo "  RULE rule_name ON table_name |"
	echo "  SCHEMA object_name |"
	echo "  SEQUENCE object_name |"
	echo "  TRIGGER trigger_name ON table_name |"
	echo "  TYPE object_name |"
	echo "  VIEW object_name"
	echo "} IS 'text'"
	;;

	"commit" | "COMMIT" )
	echo "Command:     COMMIT"
	echo "Description: commit the current transaction"
	echo "Syntax:"
	echo "COMMIT [ WORK | TRANSACTION ]"
	;;

	"commit prepared" | "COMMIT PREPARED" )
	echo "Command:     COMMIT PREPARED"
	echo "Description: commit a transaction that was earlier prepared for two-phase commit"
	echo "Syntax:"
	echo "COMMIT PREPARED transaction_id"
	;;

	"copy" | "COPY" )
	echo "Command:     COPY"
	echo "Description: copy data between a file and a table"
	echo "Syntax:"
	echo "COPY tablename [ ( column [, ...] ) ]"
	echo "    FROM { 'filename' | STDIN }"
	echo "    [ [ WITH ] "
	echo "          [ BINARY ]"
	echo "          [ OIDS ]"
	echo "          [ DELIMITER [ AS ] 'delimiter' ]"
	echo "          [ NULL [ AS ] 'null string' ]"
	echo "          [ CSV [ HEADER ]"
	echo "                [ QUOTE [ AS ] 'quote' ] "
	echo "                [ ESCAPE [ AS ] 'escape' ]"
	echo "                [ FORCE NOT NULL column [, ...] ]"
	echo ""
	echo "COPY tablename [ ( column [, ...] ) ]"
	echo "    TO { 'filename' | STDOUT }"
	echo "    [ [ WITH ] "
	echo "          [ BINARY ]"
	echo "          [ HEADER ]"
	echo "          [ OIDS ]"
	echo "          [ DELIMITER [ AS ] 'delimiter' ]"
	echo "          [ NULL [ AS ] 'null string' ]"
	echo "          [ CSV [ HEADER ]"
	echo "                [ QUOTE [ AS ] 'quote' ] "
	echo "                [ ESCAPE [ AS ] 'escape' ]"
	echo "                [ FORCE QUOTE column [, ...] ]"
	;;

	"create aggregate" | "CREATE AGGREGATE" )
	echo "Command:     CREATE AGGREGATE"
	echo "Description: define a new aggregate function"
	echo "Syntax:"
	echo "CREATE AGGREGATE name ("
	echo "    BASETYPE = input_data_type,"
	echo "    SFUNC = sfunc,"
	echo "    STYPE = state_data_type"
	echo "    [ , FINALFUNC = ffunc ]"
	echo "    [ , INITCOND = initial_condition ]"
	echo "    [ , SORTOP = sort_operator ]"
	echo ")"
	;;

	"create cast" | "CREATE CAST" )
	echo "Command:     CREATE CAST"
	echo "Description: define a new cast"
	echo "Syntax:"
	echo "CREATE CAST (sourcetype AS targettype)"
	echo "    WITH FUNCTION funcname (argtypes)"
	echo "    [ AS ASSIGNMENT | AS IMPLICIT ]"
	echo ""
	echo "CREATE CAST (sourcetype AS targettype)"
	echo "    WITHOUT FUNCTION"
	echo "    [ AS ASSIGNMENT | AS IMPLICIT ]"
	;;

	"create constraint trigger" | "CREATE CONSTRAINT TRIGGER" )
	echo "Command:     CREATE CONSTRAINT TRIGGER"
	echo "Description: define a new constraint trigger"
	echo "Syntax:"
	echo "CREATE CONSTRAINT TRIGGER name"
	echo "    AFTER events ON"
	echo "    tablename constraint attributes"
	echo "    FOR EACH ROW EXECUTE PROCEDURE funcname ( args )"
	;;

	"create conversion" | "CREATE CONVERSION" )
	echo "Command:     CREATE CONVERSION"
	echo "Description: define a new encoding conversion"
	echo "Syntax:"
	echo "CREATE [DEFAULT] CONVERSION name"
	echo "    FOR source_encoding TO dest_encoding FROM funcname"
	;;

	"create database" | "CREATE DATABASE" )
	echo "Command:     CREATE DATABASE"
	echo "Description: create a new database"
	echo "Syntax:"
	echo "CREATE DATABASE name"
	echo "    [ [ WITH ] [ OWNER [=] dbowner ]"
	echo "           [ TEMPLATE [=] template ]"
	echo "           [ ENCODING [=] encoding ]"
	echo "           [ TABLESPACE [=] tablespace ]"
	echo "           [ CONNECTION LIMIT [=] connlimit ] ]"
	;;

	"create domain" | "CREATE DOMAIN" )
	echo "Command:     CREATE DOMAIN"
	echo "Description: define a new domain"
	echo "Syntax:"
	echo "CREATE DOMAIN name [AS] data_type"
	echo "    [ DEFAULT expression ]"
	echo "    [ constraint [ ... ] ]"
	echo ""
	echo "where constraint is:"
	echo ""
	echo "[ CONSTRAINT constraint_name ]"
	echo "{ NOT NULL | NULL | CHECK (expression) }"
	;;

	"create function" | "CREATE FUNCTION" )
	echo "Command:     CREATE FUNCTION"
	echo "Description: define a new function"
	echo "Syntax:"
	echo "CREATE [ OR REPLACE ] FUNCTION"
	echo "    name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    [ RETURNS rettype ]"
	echo "  { LANGUAGE langname"
	echo "    | IMMUTABLE | STABLE | VOLATILE"
	echo "    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT"
	echo "    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER"
	echo "    | AS 'definition'"
	echo "    | AS 'obj_file', 'link_symbol'"
	echo "  } ..."
	echo "    [ WITH ( attribute [, ...] ) ]"
	;;

	"create group" | "CREATE GROUP" )
	echo "Command:     CREATE GROUP"
	echo "Description: define a new database role"
	echo "Syntax:"
	echo "CREATE GROUP name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo "    | IN ROLE rolename [, ...]"
	echo "    | IN GROUP rolename [, ...]"
	echo "    | ROLE rolename [, ...]"
	echo "    | ADMIN rolename [, ...]"
	echo "    | USER rolename [, ...]"
	echo "    | SYSID uid"
	;;

	"create index" | "CREATE INDEX" )
	echo "Command:     CREATE INDEX"
	echo "Description: define a new index"
	echo "Syntax:"
	echo "CREATE [ UNIQUE ] INDEX name ON table [ USING method ]"
	echo "    ( { column | ( expression ) } [ opclass ] [, ...] )"
	echo "    [ TABLESPACE tablespace ]"
	echo "    [ WHERE predicate ]"
	;;

	"create language" | "CREATE LANGUAGE" )
	echo "Command:     CREATE LANGUAGE"
	echo "Description: define a new procedural language"
	echo "Syntax:"
	echo "CREATE [ PROCEDURAL ] LANGUAGE name"
	echo "CREATE [ TRUSTED ] [ PROCEDURAL ] LANGUAGE name"
	echo "    HANDLER call_handler [ VALIDATOR valfunction ]"
	;;

	"create operator class" | "CREATE OPERATOR CLASS" )
	echo "Command:     CREATE OPERATOR CLASS"
	echo "Description: define a new operator class"
	echo "Syntax:"
	echo "CREATE OPERATOR CLASS name [ DEFAULT ] FOR TYPE data_type USING index_method AS"
	echo "  {  OPERATOR strategy_number operator_name [ ( op_type, op_type ) ] [ RECHECK ]"
	echo "   | FUNCTION support_number funcname ( argument_type [, ...] )"
	echo "   | STORAGE storage_type"
	echo "  } [, ... ]"
	;;

	"create operator" | "CREATE OPERATOR" )
	echo "Command:     CREATE OPERATOR"
	echo "Description: define a new operator"
	echo "Syntax:"
	echo "CREATE OPERATOR name ("
	echo "    PROCEDURE = funcname"
	echo "    [, LEFTARG = lefttype ] [, RIGHTARG = righttype ]"
	echo "    [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ]"
	echo "    [, RESTRICT = res_proc ] [, JOIN = join_proc ]"
	echo "    [, HASHES ] [, MERGES ]"
	echo "    [, SORT1 = left_sort_op ] [, SORT2 = right_sort_op ]"
	echo "    [, LTCMP = less_than_op ] [, GTCMP = greater_than_op ]"
	echo ")"
	;;

	"create role" | "CREATE ROLE" )
	echo "Command:     CREATE ROLE"
	echo "Description: define a new database role"
	echo "Syntax:"
	echo "CREATE ROLE name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | CONNECTION LIMIT connlimit"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo "    | IN ROLE rolename [, ...]"
	echo "    | IN GROUP rolename [, ...]"
	echo "    | ROLE rolename [, ...]"
	echo "    | ADMIN rolename [, ...]"
	echo "    | USER rolename [, ...]"
	echo "    | SYSID uid"
	;;

	"create rule" | "CREATE RULE" )
	echo "Command:     CREATE RULE"
	echo "Description: define a new rewrite rule"
	echo "Syntax:"
	echo "CREATE [ OR REPLACE ] RULE name AS ON event"
	echo "    TO table [ WHERE condition ]"
	echo "    DO [ ALSO | INSTEAD ] { NOTHING | command | ( command ; command ... ) }"
	;;

	"create schema" | "CREATE SCHEMA" )
	echo "Command:     CREATE SCHEMA"
	echo "Description: define a new schema"
	echo "Syntax:"
	echo "CREATE SCHEMA schemaname [ AUTHORIZATION username ] [ schema_element [ ... ] ]"
	echo "CREATE SCHEMA AUTHORIZATION username [ schema_element [ ... ] ]"
	;;

	"create sequence" | "CREATE SEQUENCE" )
	echo "Command:     CREATE SEQUENCE"
	echo "Description: define a new sequence generator"
	echo "Syntax:"
	echo "CREATE [ TEMPORARY | TEMP ] SEQUENCE name [ INCREMENT [ BY ] increment ]"
	echo "    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]"
	echo "    [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]"
	;;

	"create table" | "CREATE TABLE" )
	echo "Command:     CREATE TABLE"
	echo "Description: define a new table"
	echo "Syntax:"
	echo "CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name ( ["
	echo "  { column_name data_type [ DEFAULT default_expr ] [ column_constraint [ ... ] ]"
	echo "    | table_constraint"
	echo "    | LIKE parent_table [ { INCLUDING | EXCLUDING } DEFAULTS ] }"
	echo "    [, ... ]"
	echo "] )"
	echo "[ INHERITS ( parent_table [, ... ] ) ]"
	echo "[ WITH OIDS | WITHOUT OIDS ]"
	echo "[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]"
	echo "[ TABLESPACE tablespace ]"
	echo ""
	echo "where column_constraint is:"
	echo ""
	echo "[ CONSTRAINT constraint_name ]"
	echo "{ NOT NULL | "
	echo "  NULL | "
	echo "  UNIQUE [ USING INDEX TABLESPACE tablespace ] |"
	echo "  PRIMARY KEY [ USING INDEX TABLESPACE tablespace ] |"
	echo "  CHECK (expression) |"
	echo "  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]"
	echo "    [ ON DELETE action ] [ ON UPDATE action ] }"
	echo "[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]"
	echo ""
	echo "and table_constraint is:"
	echo ""
	echo "[ CONSTRAINT constraint_name ]"
	echo "{ UNIQUE ( column_name [, ... ] ) [ USING INDEX TABLESPACE tablespace ] |"
	echo "  PRIMARY KEY ( column_name [, ... ] ) [ USING INDEX TABLESPACE tablespace ] |"
	echo "  CHECK ( expression ) |"
	echo "  FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]"
	echo "    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] }"
	echo "[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]"
	;;

	"create table as" | "CREATE TABLE AS" )
	echo "Command:     CREATE TABLE AS"
	echo "Description: define a new table from the results of a query"
	echo "Syntax:"
	echo "CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name"
	echo "    [ (column_name [, ...] ) ] [ [ WITH | WITHOUT ] OIDS ]"
	echo "    AS query"
	;;

	"create tablespace" | "CREATE TABLESPACE" )
	echo "Command:     CREATE TABLESPACE"
	echo "Description: define a new tablespace"
	echo "Syntax:"
	echo "CREATE TABLESPACE tablespacename [ OWNER username ] LOCATION 'directory'"
	;;

	"create trigger" | "CREATE TRIGGER" )
	echo "Command:     CREATE TRIGGER"
	echo "Description: define a new trigger"
	echo "Syntax:"
	echo "CREATE TRIGGER name { BEFORE | AFTER } { event [ OR ... ] }"
	echo "    ON table [ FOR [ EACH ] { ROW | STATEMENT } ]"
	echo "    EXECUTE PROCEDURE funcname ( arguments )"
	;;

	"create type" | "CREATE TYPE" )
	echo "Command:     CREATE TYPE"
	echo "Description: define a new data type"
	echo "Syntax:"
	echo "CREATE TYPE name AS"
	echo "    ( attribute_name data_type [, ... ] )"
	echo ""
	echo "CREATE TYPE name ("
	echo "    INPUT = input_function,"
	echo "    OUTPUT = output_function"
	echo "    [ , RECEIVE = receive_function ]"
	echo "    [ , SEND = send_function ]"
	echo "    [ , ANALYZE = analyze_function ]"
	echo "    [ , INTERNALLENGTH = { internallength | VARIABLE } ]"
	echo "    [ , PASSEDBYVALUE ]"
	echo "    [ , ALIGNMENT = alignment ]"
	echo "    [ , STORAGE = storage ]"
	echo "    [ , DEFAULT = default ]"
	echo "    [ , ELEMENT = element ]"
	echo "    [ , DELIMITER = delimiter ]"
	echo ")"
	;;

	"create user" | "CREATE USER" )
	echo "Command:     CREATE USER"
	echo "Description: define a new database role"
	echo "Syntax:"
	echo "CREATE USER name [ [ WITH ] option [ ... ] ]"
	echo ""
	echo "where option can be:"
	echo "    "
	echo "      SUPERUSER | NOSUPERUSER"
	echo "    | CREATEDB | NOCREATEDB"
	echo "    | CREATEROLE | NOCREATEROLE"
	echo "    | CREATEUSER | NOCREATEUSER"
	echo "    | INHERIT | NOINHERIT"
	echo "    | LOGIN | NOLOGIN"
	echo "    | CONNECTION LIMIT connlimit"
	echo "    | [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'"
	echo "    | VALID UNTIL 'timestamp' "
	echo "    | IN ROLE rolename [, ...]"
	echo "    | IN GROUP rolename [, ...]"
	echo "    | ROLE rolename [, ...]"
	echo "    | ADMIN rolename [, ...]"
	echo "    | USER rolename [, ...]"
	echo "    | SYSID uid"
	;;

	"create view" | "CREATE VIEW" )
	echo "Command:     CREATE VIEW"
	echo "Description: define a new view"
	echo "Syntax:"
	echo "CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] VIEW name [ ( column_name [, ...] ) ]"
	echo "    AS query"
	;;

	"deallocate" | "DEALLOCATE" )
	echo "Command:     DEALLOCATE"
	echo "Description: deallocate a prepared statement"
	echo "Syntax:"
	echo "DEALLOCATE [ PREPARE ] plan_name"
	;;

	"declare" | "DECLARE" )
	echo "Command:     DECLARE"
	echo "Description: define a cursor"
	echo "Syntax:"
	echo "DECLARE name [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]"
	echo "    CURSOR [ { WITH | WITHOUT } HOLD ] FOR query"
	echo "    [ FOR { READ ONLY | UPDATE [ OF column [, ...] ] } ]"
	;;

	"delete" | "DELETE" )
	echo "Command:     DELETE"
	echo "Description: delete rows of a table"
	echo "Syntax:"
	echo "DELETE FROM [ ONLY ] table"
	echo "    [ USING usinglist ]"
	echo "    [ WHERE condition ]"
	;;

	"drop aggregate" | "DROP AGGREGATE" )
	echo "Command:     DROP AGGREGATE"
	echo "Description: remove an aggregate function"
	echo "Syntax:"
	echo "DROP AGGREGATE name ( type ) [ CASCADE | RESTRICT ]"
	;;

	"drop cast" | "DROP CAST" )
	echo "Command:     DROP CAST"
	echo "Description: remove a cast"
	echo "Syntax:"
	echo "DROP CAST (sourcetype AS targettype) [ CASCADE | RESTRICT ]"
	;;

	"drop conversion" | "DROP CONVERSION" )
	echo "Command:     DROP CONVERSION"
	echo "Description: remove a conversion"
	echo "Syntax:"
	echo "DROP CONVERSION name [ CASCADE | RESTRICT ]"
	;;

	"drop database" | "DROP DATABASE" )
	echo "Command:     DROP DATABASE"
	echo "Description: remove a database"
	echo "Syntax:"
	echo "DROP DATABASE name"
	;;

	"drop domain" | "DROP DOMAIN" )
	echo "Command:     DROP DOMAIN"
	echo "Description: remove a domain"
	echo "Syntax:"
	echo "DROP DOMAIN name [, ...]  [ CASCADE | RESTRICT ]"
	;;

	"drop function" | "DROP FUNCTION" )
	echo "Command:     DROP FUNCTION"
	echo "Description: remove a function"
	echo "Syntax:"
	echo "DROP FUNCTION name ( [ [ argmode ] [ argname ] argtype [, ...] ] )"
	echo "    [ CASCADE | RESTRICT ]"
	;;

	"drop group" | "DROP GROUP" )
	echo "Command:     DROP GROUP"
	echo "Description: remove a database role"
	echo "Syntax:"
	echo "DROP GROUP name [, ...]"
	;;

	"drop index" | "DROP INDEX" )
	echo "Command:     DROP INDEX"
	echo "Description: remove an index"
	echo "Syntax:"
	echo "DROP INDEX name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop language" | "DROP LANGUAGE" )
	echo "Command:     DROP LANGUAGE"
	echo "Description: remove a procedural language"
	echo "Syntax:"
	echo "DROP [ PROCEDURAL ] LANGUAGE name [ CASCADE | RESTRICT ]"
	;;

	"drop operator class" | "DROP OPERATOR CLASS" )
	echo "Command:     DROP OPERATOR CLASS"
	echo "Description: remove an operator class"
	echo "Syntax:"
	echo "DROP OPERATOR CLASS name USING index_method [ CASCADE | RESTRICT ]"
	;;

	"drop operator" | "DROP OPERATOR" )
	echo "Command:     DROP OPERATOR"
	echo "Description: remove an operator"
	echo "Syntax:"
	echo "DROP OPERATOR name ( { lefttype | NONE } , { righttype | NONE } ) [ CASCADE | RESTRICT ]"
	;;

	"drop role" | "DROP ROLE" )
	echo "Command:     DROP ROLE"
	echo "Description: remove a database role"
	echo "Syntax:"
	echo "DROP ROLE name [, ...]"
	;;

	"drop rule" | "DROP RULE" )
	echo "Command:     DROP RULE"
	echo "Description: remove a rewrite rule"
	echo "Syntax:"
	echo "DROP RULE name ON relation [ CASCADE | RESTRICT ]"
	;;

	"drop schema" | "DROP SCHEMA" )
	echo "Command:     DROP SCHEMA"
	echo "Description: remove a schema"
	echo "Syntax:"
	echo "DROP SCHEMA name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop sequence" | "DROP SEQUENCE" )
	echo "Command:     DROP SEQUENCE"
	echo "Description: remove a sequence"
	echo "Syntax:"
	echo "DROP SEQUENCE name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop table" | "DROP TABLE" )
	echo "Command:     DROP TABLE"
	echo "Description: remove a table"
	echo "Syntax:"
	echo "DROP TABLE name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop tablespace" | "DROP TABLESPACE" )
	echo "Command:     DROP TABLESPACE"
	echo "Description: remove a tablespace"
	echo "Syntax:"
	echo "DROP TABLESPACE tablespacename"
	;;

	"drop trigger" | "DROP TRIGGER" )
	echo "Command:     DROP TRIGGER"
	echo "Description: remove a trigger"
	echo "Syntax:"
	echo "DROP TRIGGER name ON table [ CASCADE | RESTRICT ]"
	;;

	"drop type" | "DROP TYPE" )
	echo "Command:     DROP TYPE"
	echo "Description: remove a data type"
	echo "Syntax:"
	echo "DROP TYPE name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"drop user" | "DROP USER" )
	echo "Command:     DROP USER"
	echo "Description: remove a database role"
	echo "Syntax:"
	echo "DROP USER name [, ...]"
	;;

	"drop view" | "DROP VIEW" )
	echo "Command:     DROP VIEW"
	echo "Description: remove a view"
	echo "Syntax:"
	echo "DROP VIEW name [, ...] [ CASCADE | RESTRICT ]"
	;;

	"end" | "END" )
	echo "Command:     END"
	echo "Description: commit the current transaction"
	echo "Syntax:"
	echo "END [ WORK | TRANSACTION ]"
	;;

	"execute" | "EXECUTE" )
	echo "Command:     EXECUTE"
	echo "Description: execute a prepared statement"
	echo "Syntax:"
	echo "EXECUTE plan_name [ (parameter [, ...] ) ]"
	;;

	"explain" | "EXPLAIN" )
	echo "Command:     EXPLAIN"
	echo "Description: show the execution plan of a statement"
	echo "Syntax:"
	echo "EXPLAIN [ ANALYZE ] [ VERBOSE ] statement"
	;;

	"fetch" | "FETCH" )
	echo "Command:     FETCH"
	echo "Description: retrieve rows from a query using a cursor"
	echo "Syntax:"
	echo "FETCH [ direction { FROM | IN } ] cursorname"
	echo ""
	echo "where direction can be empty or one of:"
	echo ""
	echo "    NEXT"
	echo "    PRIOR"
	echo "    FIRST"
	echo "    LAST"
	echo "    ABSOLUTE count"
	echo "    RELATIVE count"
	echo "    count"
	echo "    ALL"
	echo "    FORWARD"
	echo "    FORWARD count"
	echo "    FORWARD ALL"
	echo "    BACKWARD"
	echo "    BACKWARD count"
	echo "    BACKWARD ALL"
	;;

	"grant" | "GRANT" )
	echo "Command:     GRANT"
	echo "Description: define access privileges"
	echo "Syntax:"
	echo "GRANT { { SELECT | INSERT | UPDATE | DELETE | RULE | REFERENCES | TRIGGER }"
	echo "    [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON [ TABLE ] tablename [, ...]"
	echo "    TO { username | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { { CREATE | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON DATABASE dbname [, ...]"
	echo "    TO { username | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { EXECUTE | ALL [ PRIVILEGES ] }"
	echo "    ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...]"
	echo "    TO { username | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { USAGE | ALL [ PRIVILEGES ] }"
	echo "    ON LANGUAGE langname [, ...]"
	echo "    TO { username | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON SCHEMA schemaname [, ...]"
	echo "    TO { username | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT { CREATE | ALL [ PRIVILEGES ] }"
	echo "    ON TABLESPACE tablespacename [, ...]"
	echo "    TO { username | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]"
	echo ""
	echo "GRANT role [, ...] TO username [, ...] [ WITH ADMIN OPTION ]"
	;;

	"insert" | "INSERT" )
	echo "Command:     INSERT"
	echo "Description: create new rows in a table"
	echo "Syntax:"
	echo "INSERT INTO table [ ( column [, ...] ) ]"
	echo "    { DEFAULT VALUES | VALUES ( { expression | DEFAULT } [, ...] ) | query }"
	;;

	"listen" | "LISTEN" )
	echo "Command:     LISTEN"
	echo "Description: listen for a notification"
	echo "Syntax:"
	echo "LISTEN name"
	;;

	"load" | "LOAD" )
	echo "Command:     LOAD"
	echo "Description: load or reload a shared library file"
	echo "Syntax:"
	echo "LOAD 'filename'"
	;;

	"lock" | "LOCK" )
	echo "Command:     LOCK"
	echo "Description: lock a table"
	echo "Syntax:"
	echo "LOCK [ TABLE ] name [, ...] [ IN lockmode MODE ] [ NOWAIT ]"
	echo ""
	echo "where lockmode is one of:"
	echo ""
	echo "    ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE"
	echo "    | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE"
	;;

	"move" | "MOVE" )
	echo "Command:     MOVE"
	echo "Description: position a cursor"
	echo "Syntax:"
	echo "MOVE [ direction { FROM | IN } ] cursorname"
	;;

	"notify" | "NOTIFY" )
	echo "Command:     NOTIFY"
	echo "Description: generate a notification"
	echo "Syntax:"
	echo "NOTIFY name"
	;;

	"prepare" | "PREPARE" )
	echo "Command:     PREPARE"
	echo "Description: prepare a statement for execution"
	echo "Syntax:"
	echo "PREPARE plan_name [ (datatype [, ...] ) ] AS statement"
	;;

	"prepare transaction" | "PREPARE TRANSACTION" )
	echo "Command:     PREPARE TRANSACTION"
	echo "Description: prepare the current transaction for two-phase commit"
	echo "Syntax:"
	echo "PREPARE TRANSACTION transaction_id"
	;;

	"reindex" | "REINDEX" )
	echo "Command:     REINDEX"
	echo "Description: rebuild indexes"
	echo "Syntax:"
	echo "REINDEX { INDEX | TABLE | DATABASE | SYSTEM } name [ FORCE ]"
	;;

	"release savepoint" | "RELEASE SAVEPOINT" )
	echo "Command:     RELEASE SAVEPOINT"
	echo "Description: destroy a previously defined savepoint"
	echo "Syntax:"
	echo "RELEASE [ SAVEPOINT ] savepoint_name"
	;;

	"reset" | "RESET" )
	echo "Command:     RESET"
	echo "Description: restore the value of a run-time parameter to the default value"
	echo "Syntax:"
	echo "RESET name"
	echo "RESET ALL"
	;;

	"revoke" | "REVOKE" )
	echo "Command:     REVOKE"
	echo "Description: remove access privileges"
	echo "Syntax:"
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { { SELECT | INSERT | UPDATE | DELETE | RULE | REFERENCES | TRIGGER }"
	echo "    [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON [ TABLE ] tablename [, ...]"
	echo "    FROM { username | GROUP groupname | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { { CREATE | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON DATABASE dbname [, ...]"
	echo "    FROM { username | GROUP groupname | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { EXECUTE | ALL [ PRIVILEGES ] }"
	echo "    ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...]"
	echo "    FROM { username | GROUP groupname | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { USAGE | ALL [ PRIVILEGES ] }"
	echo "    ON LANGUAGE langname [, ...]"
	echo "    FROM { username | GROUP groupname | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }"
	echo "    ON SCHEMA schemaname [, ...]"
	echo "    FROM { username | GROUP groupname | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ GRANT OPTION FOR ]"
	echo "    { CREATE | ALL [ PRIVILEGES ] }"
	echo "    ON TABLESPACE tablespacename [, ...]"
	echo "    FROM { username | GROUP groupname | PUBLIC } [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	echo ""
	echo "REVOKE [ ADMIN OPTION FOR ]"
	echo "    role [, ...] FROM username [, ...]"
	echo "    [ CASCADE | RESTRICT ]"
	;;

	"rollback" | "ROLLBACK" )
	echo "Command:     ROLLBACK"
	echo "Description: abort the current transaction"
	echo "Syntax:"
	echo "ROLLBACK [ WORK | TRANSACTION ]"
	;;

	"rollback prepared" | "ROLLBACK PREPARED" )
	echo "Command:     ROLLBACK PREPARED"
	echo "Description: cancel a transaction that was earlier prepared for two-phase commit"
	echo "Syntax:"
	echo "ROLLBACK PREPARED transaction_id"
	;;

	"rollback to savepoint" | "ROLLBACK TO SAVEPOINT" )
	echo "Command:     ROLLBACK TO SAVEPOINT"
	echo "Description: roll back to a savepoint"
	echo "Syntax:"
	echo "ROLLBACK [ WORK | TRANSACTION ] TO [ SAVEPOINT ] savepoint_name"
	;;

	"savepoint" | "SAVEPOINT" )
	echo "Command:     SAVEPOINT"
	echo "Description: define a new savepoint within the current transaction"
	echo "Syntax:"
	echo "SAVEPOINT savepoint_name"
	;;

	"select" | "SELECT" )
	echo "Command:     SELECT"
	echo "Description: retrieve rows from a table or view"
	echo "Syntax:"
	echo "SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]"
	echo "    * | expression [ AS output_name ] [, ...]"
	echo "    [ FROM from_item [, ...] ]"
	echo "    [ WHERE condition ]"
	echo "    [ GROUP BY expression [, ...] ]"
	echo "    [ HAVING condition [, ...] ]"
	echo "    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]"
	echo "    [ ORDER BY expression [ ASC | DESC | USING operator ] [, ...] ]"
	echo "    [ LIMIT { count | ALL } ]"
	echo "    [ OFFSET start ]"
	echo "    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ] ]"
	echo ""
	echo "where from_item can be one of:"
	echo ""
	echo "    [ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]"
	echo "    ( select ) [ AS ] alias [ ( column_alias [, ...] ) ]"
	echo "    function_name ( [ argument [, ...] ] ) [ AS ] alias [ ( column_alias [, ...] | column_definition [, ...] ) ]"
	echo "    function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )"
	echo "    from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ]"
	;;

	"select into" | "SELECT INTO" )
	echo "Command:     SELECT INTO"
	echo "Description: define a new table from the results of a query"
	echo "Syntax:"
	echo "SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]"
	echo "    * | expression [ AS output_name ] [, ...]"
	echo "    INTO [ TEMPORARY | TEMP ] [ TABLE ] new_table"
	echo "    [ FROM from_item [, ...] ]"
	echo "    [ WHERE condition ]"
	echo "    [ GROUP BY expression [, ...] ]"
	echo "    [ HAVING condition [, ...] ]"
	echo "    [ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]"
	echo "    [ ORDER BY expression [ ASC | DESC | USING operator ] [, ...] ]"
	echo "    [ LIMIT { count | ALL } ]"
	echo "    [ OFFSET start ]"
	echo "    [ FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ] ]"
	;;

	"set" | "SET" )
	echo "Command:     SET"
	echo "Description: change a run-time parameter"
	echo "Syntax:"
	echo "SET [ SESSION | LOCAL ] name { TO | = } { value | 'value' | DEFAULT }"
	echo "SET [ SESSION | LOCAL ] TIME ZONE { timezone | LOCAL | DEFAULT }"
	;;

	"set constraints" | "SET CONSTRAINTS" )
	echo "Command:     SET CONSTRAINTS"
	echo "Description: set constraint checking modes for the current transaction"
	echo "Syntax:"
	echo "SET CONSTRAINTS { ALL | name [, ...] } { DEFERRED | IMMEDIATE }"
	;;

	"set role" | "SET ROLE" )
	echo "Command:     SET ROLE"
	echo "Description: set the current user identifier of the current session"
	echo "Syntax:"
	echo "SET [ SESSION | LOCAL ] ROLE rolename"
	echo "SET [ SESSION | LOCAL ] ROLE NONE"
	echo "RESET ROLE"
	;;

	"set session authorization" | "SET SESSION AUTHORIZATION" )
	echo "Command:     SET SESSION AUTHORIZATION"
	echo "Description: set the session user identifier and the current user identifier of the current session"
	echo "Syntax:"
	echo "SET [ SESSION | LOCAL ] SESSION AUTHORIZATION username"
	echo "SET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT"
	echo "RESET SESSION AUTHORIZATION"
	;;

	"set transaction" | "SET TRANSACTION" )
	echo "Command:     SET TRANSACTION"
	echo "Description: set the characteristics of the current transaction"
	echo "Syntax:"
	echo "SET TRANSACTION transaction_mode [, ...]"
	echo "SET SESSION CHARACTERISTICS AS TRANSACTION transaction_mode [, ...]"
	echo ""
	echo "where transaction_mode is one of:"
	echo ""
	echo "    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }"
	echo "    READ WRITE | READ ONLY"
	;;

	"show" | "SHOW" )
	echo "Command:     SHOW"
	echo "Description: show the value of a run-time parameter"
	echo "Syntax:"
	echo "SHOW name"
	echo "SHOW ALL"
	;;

	"start transaction" | "START TRANSACTION" )
	echo "Command:     START TRANSACTION"
	echo "Description: start a transaction block"
	echo "Syntax:"
	echo "START TRANSACTION [ transaction_mode [, ...] ]"
	echo ""
	echo "where transaction_mode is one of:"
	echo ""
	echo "    ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED | READ UNCOMMITTED }"
	echo "    READ WRITE | READ ONLY"
	;;

	"truncate" | "TRUNCATE" )
	echo "Command:     TRUNCATE"
	echo "Description: empty a table or set of tables"
	echo "Syntax:"
	echo "TRUNCATE [ TABLE ] name [, ...]"
	;;

	"unlisten" | "UNLISTEN" )
	echo "Command:     UNLISTEN"
	echo "Description: stop listening for a notification"
	echo "Syntax:"
	echo "UNLISTEN { name | * }"
	;;

	"update" | "UPDATE" )
	echo "Command:     UPDATE"
	echo "Description: update rows of a table"
	echo "Syntax:"
	echo "UPDATE [ ONLY ] table SET column = { expression | DEFAULT } [, ...]"
	echo "    [ FROM fromlist ]"
	echo "    [ WHERE condition ]"
	;;

	"vacuum" | "VACUUM" )
	echo "Command:     VACUUM"
	echo "Description: garbage-collect and optionally analyze a database"
	echo "Syntax:"
	echo "VACUUM [ FULL | FREEZE ] [ VERBOSE ] [ table ]"
	echo "VACUUM [ FULL | FREEZE ] [ VERBOSE ] ANALYZE [ table [ (column [, ...] ) ] ]"
	;;

	* )
	echo "ABORT                     CREATE LANGUAGE           DROP VIEW"
	echo "ALTER AGGREGATE           CREATE OPERATOR CLASS     END"
	echo "ALTER CONVERSION          CREATE OPERATOR           EXECUTE"
	echo "ALTER DATABASE            CREATE ROLE               EXPLAIN"
	echo "ALTER DOMAIN              CREATE RULE               FETCH"
	echo "ALTER FUNCTION            CREATE SCHEMA             GRANT"
	echo "ALTER GROUP               CREATE SEQUENCE           INSERT"
	echo "ALTER INDEX               CREATE TABLE              LISTEN"
	echo "ALTER LANGUAGE            CREATE TABLE AS           LOAD"
	echo "ALTER OPERATOR CLASS      CREATE TABLESPACE         LOCK"
	echo "ALTER OPERATOR            CREATE TRIGGER            MOVE"
	echo "ALTER ROLE                CREATE TYPE               NOTIFY"
	echo "ALTER SCHEMA              CREATE USER               PREPARE"
	echo "ALTER SEQUENCE            CREATE VIEW               PREPARE TRANSACTION"
	echo "ALTER TABLE               DEALLOCATE                REINDEX"
	echo "ALTER TABLESPACE          DECLARE                   RELEASE SAVEPOINT"
	echo "ALTER TRIGGER             DELETE                    RESET"
	echo "ALTER TYPE                DROP AGGREGATE            REVOKE"
	echo "ALTER USER                DROP CAST                 ROLLBACK"
	echo "ANALYZE                   DROP CONVERSION           ROLLBACK PREPARED"
	echo "BEGIN                     DROP DATABASE             ROLLBACK TO SAVEPOINT"
	echo "CHECKPOINT                DROP DOMAIN               SAVEPOINT"
	echo "CLOSE                     DROP FUNCTION             SELECT"
	echo "CLUSTER                   DROP GROUP                SELECT INTO"
	echo "COMMENT                   DROP INDEX                SET"
	echo "COMMIT                    DROP LANGUAGE             SET CONSTRAINTS"
	echo "COMMIT PREPARED           DROP OPERATOR CLASS       SET ROLE"
	echo "COPY                      DROP OPERATOR             SET SESSION AUTHORIZATION"
	echo "CREATE AGGREGATE          DROP ROLE                 SET TRANSACTION"
	echo "CREATE CAST               DROP RULE                 SHOW"
	echo "CREATE CONSTRAINT TRIGGER DROP SCHEMA               START TRANSACTION"
	echo "CREATE CONVERSION         DROP SEQUENCE             TRUNCATE"
	echo "CREATE DATABASE           DROP TABLE                UNLISTEN"
	echo "CREATE DOMAIN             DROP TABLESPACE           UPDATE"
	echo "CREATE FUNCTION           DROP TRIGGER              VACUUM"
	echo "CREATE GROUP              DROP TYPE"
	echo "CREATE INDEX              DROP USER"
	;;

	esac

	echo ""
}
